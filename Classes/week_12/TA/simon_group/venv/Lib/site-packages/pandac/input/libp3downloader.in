1608630768
3 3
15 libp3downloader 4 _Rn_ 12 panda3d.core 
393
399 9 ~SSReader 0 6 792 19 SSReader::~SSReader 0 0 10
/**
 *
 */
34
virtual SSReader::~SSReader(void);

400 16 receive_datagram 0 4 792 26 SSReader::receive_datagram 0 1 1 253
/**
 * Receives a datagram over the socket by expecting a little-endian 16-bit
 * byte count as a prefix.  If the socket stream is non-blocking, may return
 * false if the data is not available; otherwise, returns false only if the
 * socket closes.
 */
53
inline bool SSReader::receive_datagram(Datagram &dg);

401 9 is_closed 0 6 792 19 SSReader::is_closed 0 1 2 0
43
virtual bool SSReader::is_closed(void) = 0;

402 5 close 0 6 792 15 SSReader::close 0 1 3 0
39
virtual void SSReader::close(void) = 0;

403 19 set_tcp_header_size 0 4 792 29 SSReader::set_tcp_header_size 0 1 4 269
/**
 * Sets the header size for datagrams.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */
63
inline void SSReader::set_tcp_header_size(int tcp_header_size);

404 19 get_tcp_header_size 0 4 792 29 SSReader::get_tcp_header_size 0 1 5 77
/**
 * Returns the header size for datagrams.  See set_tcp_header_size().
 */
53
inline int SSReader::get_tcp_header_size(void) const;

405 9 ~SSWriter 0 6 793 19 SSWriter::~SSWriter 0 0 10
/**
 *
 */
34
virtual SSWriter::~SSWriter(void);

406 13 send_datagram 0 4 793 23 SSWriter::send_datagram 0 1 6 234
/**
 * Transmits the indicated datagram over the socket by prepending it with a
 * little-endian 16-bit byte count.  Does not return until the data is sent or
 * the connection is closed, even if the socket stream is non-blocking.
 */
49
bool SSWriter::send_datagram(Datagram const &dg);

407 9 is_closed 0 6 793 19 SSWriter::is_closed 0 1 7 0
43
virtual bool SSWriter::is_closed(void) = 0;

408 5 close 0 6 793 15 SSWriter::close 0 1 8 0
39
virtual void SSWriter::close(void) = 0;

409 15 set_collect_tcp 0 4 793 25 SSWriter::set_collect_tcp 0 1 9 719
/**
 * Enables or disables "collect-tcp" mode.  In this mode, individual TCP
 * packets are not sent immediately, but rather they are collected together
 * and accumulated to be sent periodically as one larger TCP packet.  This
 * cuts down on overhead from the TCP/IP protocol, especially if many small
 * packets need to be sent on the same connection, but it introduces
 * additional latency (since packets must be held before they can be sent).
 *
 * See set_collect_tcp_interval() to specify the interval of time for which to
 * hold packets before sending them.
 *
 * If you enable this mode, you may also need to periodically call
 * consider_flush() to flush the queue if no packets have been sent recently.
 */
56
inline void SSWriter::set_collect_tcp(bool collect_tcp);

410 15 get_collect_tcp 0 4 793 25 SSWriter::get_collect_tcp 0 1 10 85
/**
 * Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().
 */
50
inline bool SSWriter::get_collect_tcp(void) const;

411 24 set_collect_tcp_interval 0 4 793 34 SSWriter::set_collect_tcp_interval 0 1 11 231
/**
 * Specifies the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */
64
inline void SSWriter::set_collect_tcp_interval(double interval);

412 24 get_collect_tcp_interval 0 4 793 34 SSWriter::get_collect_tcp_interval 0 1 12 229
/**
 * Returns the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */
61
inline double SSWriter::get_collect_tcp_interval(void) const;

413 19 set_tcp_header_size 0 4 793 29 SSWriter::set_tcp_header_size 0 1 13 269
/**
 * Sets the header size for datagrams.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */
63
inline void SSWriter::set_tcp_header_size(int tcp_header_size);

414 19 get_tcp_header_size 0 4 793 29 SSWriter::get_tcp_header_size 0 1 14 77
/**
 * Returns the header size for datagrams.  See set_tcp_header_size().
 */
53
inline int SSWriter::get_tcp_header_size(void) const;

415 14 consider_flush 0 4 793 24 SSWriter::consider_flush 0 1 15 143
/**
 * Sends the most recently queued data if enough time has elapsed.  This only
 * has meaning if set_collect_tcp() has been set to true.
 */
43
inline bool SSWriter::consider_flush(void);

416 5 flush 0 4 793 15 SSWriter::flush 0 1 16 120
/**
 * Sends the most recently queued data now.  This only has meaning if
 * set_collect_tcp() has been set to true.
 */
34
inline bool SSWriter::flush(void);

417 17 upcast_to_istream 0 12 794 32 ISocketStream::upcast_to_istream 0 1 20 36
upcast from ISocketStream to istream
53
std::istream *ISocketStream::upcast_to_istream(void);

418 25 downcast_to_ISocketStream 0 12 795 39 std::istream::downcast_to_ISocketStream 0 0 38
downcast from istream to ISocketStream
61
ISocketStream *std::istream::downcast_to_ISocketStream(void);

419 18 upcast_to_SSReader 0 12 794 33 ISocketStream::upcast_to_SSReader 0 1 21 37
upcast from ISocketStream to SSReader
50
SSReader *ISocketStream::upcast_to_SSReader(void);

420 25 downcast_to_ISocketStream 0 12 792 35 SSReader::downcast_to_ISocketStream 0 0 39
downcast from SSReader to ISocketStream
57
ISocketStream *SSReader::downcast_to_ISocketStream(void);

421 14 ~ISocketStream 0 6 794 29 ISocketStream::~ISocketStream 0 0 10
/**
 *
 */
44
virtual ISocketStream::~ISocketStream(void);

422 9 is_closed 0 6 794 24 ISocketStream::is_closed 0 1 17 0
48
virtual bool ISocketStream::is_closed(void) = 0;

423 5 close 0 6 794 20 ISocketStream::close 0 1 18 0
44
virtual void ISocketStream::close(void) = 0;

424 14 get_read_state 0 6 794 29 ISocketStream::get_read_state 0 1 19 0
73
virtual ISocketStream::ReadState ISocketStream::get_read_state(void) = 0;

425 17 upcast_to_ostream 0 12 797 32 OSocketStream::upcast_to_ostream 0 1 25 36
upcast from OSocketStream to ostream
53
std::ostream *OSocketStream::upcast_to_ostream(void);

426 25 downcast_to_OSocketStream 0 12 798 39 std::ostream::downcast_to_OSocketStream 0 0 38
downcast from ostream to OSocketStream
61
OSocketStream *std::ostream::downcast_to_OSocketStream(void);

427 18 upcast_to_SSWriter 0 12 797 33 OSocketStream::upcast_to_SSWriter 0 1 26 37
upcast from OSocketStream to SSWriter
50
SSWriter *OSocketStream::upcast_to_SSWriter(void);

428 25 downcast_to_OSocketStream 0 12 793 35 SSWriter::downcast_to_OSocketStream 0 0 39
downcast from SSWriter to OSocketStream
57
OSocketStream *SSWriter::downcast_to_OSocketStream(void);

429 9 is_closed 0 6 797 24 OSocketStream::is_closed 0 1 22 0
48
virtual bool OSocketStream::is_closed(void) = 0;

430 5 close 0 6 797 20 OSocketStream::close 0 1 23 0
44
virtual void OSocketStream::close(void) = 0;

431 5 flush 0 4 797 20 OSocketStream::flush 0 1 24 120
/**
 * Sends the most recently queued data now.  This only has meaning if
 * set_collect_tcp() has been set to true.
 */
39
inline bool OSocketStream::flush(void);

432 14 ~OSocketStream 0 4 797 29 OSocketStream::~OSocketStream 0 0 0
36
OSocketStream::~OSocketStream(void);

433 18 upcast_to_iostream 0 12 799 32 SocketStream::upcast_to_iostream 0 1 32 36
upcast from SocketStream to iostream
54
std::iostream *SocketStream::upcast_to_iostream(void);

434 24 downcast_to_SocketStream 0 12 800 39 std::iostream::downcast_to_SocketStream 0 0 38
downcast from iostream to SocketStream
60
SocketStream *std::iostream::downcast_to_SocketStream(void);

435 18 upcast_to_SSReader 0 12 799 32 SocketStream::upcast_to_SSReader 0 1 33 36
upcast from SocketStream to SSReader
49
SSReader *SocketStream::upcast_to_SSReader(void);

436 24 downcast_to_SocketStream 0 12 792 34 SSReader::downcast_to_SocketStream 0 0 38
downcast from SSReader to SocketStream
55
SocketStream *SSReader::downcast_to_SocketStream(void);

437 18 upcast_to_SSWriter 0 12 799 32 SocketStream::upcast_to_SSWriter 0 1 34 36
upcast from SocketStream to SSWriter
49
SSWriter *SocketStream::upcast_to_SSWriter(void);

438 24 downcast_to_SocketStream 0 12 793 34 SSWriter::downcast_to_SocketStream 0 0 38
downcast from SSWriter to SocketStream
55
SocketStream *SSWriter::downcast_to_SocketStream(void);

439 9 is_closed 0 6 799 23 SocketStream::is_closed 0 1 27 0
47
virtual bool SocketStream::is_closed(void) = 0;

440 5 close 0 6 799 19 SocketStream::close 0 1 28 0
43
virtual void SocketStream::close(void) = 0;

441 19 set_tcp_header_size 0 4 799 33 SocketStream::set_tcp_header_size 0 1 29 269
/**
 * Sets the header size for datagrams.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */
67
inline void SocketStream::set_tcp_header_size(int tcp_header_size);

442 19 get_tcp_header_size 0 4 799 33 SocketStream::get_tcp_header_size 0 1 30 77
/**
 * Returns the header size for datagrams.  See set_tcp_header_size().
 */
57
inline int SocketStream::get_tcp_header_size(void) const;

443 5 flush 0 4 799 19 SocketStream::flush 0 1 31 120
/**
 * Sends the most recently queued data now.  This only has meaning if
 * set_collect_tcp() has been set to true.
 */
38
inline bool SocketStream::flush(void);

444 13 ~SocketStream 0 4 799 27 SocketStream::~SocketStream 0 0 0
34
SocketStream::~SocketStream(void);

445 7 URLSpec 0 4 801 16 URLSpec::URLSpec 0 4 35 36 37 38 159
/**
 *
 */

/**
 *
 */

/**
 * Creates a URLSpec by appending a path to the end of the old URLSpec,
 * inserting an intervening forward slash if necessary.
 */
219
URLSpec::URLSpec(void);
inline URLSpec::URLSpec(std::string const &url, bool server_name_expected = false);
URLSpec::URLSpec(URLSpec const &url, Filename const &path);
inline URLSpec::URLSpec(URLSpec const &) = default;

446 10 operator = 0 4 801 19 URLSpec::operator = 0 1 39 0
56
inline void URLSpec::operator =(std::string const &url);

447 11 operator == 0 4 801 20 URLSpec::operator == 0 1 40 0
61
inline bool URLSpec::operator ==(URLSpec const &other) const;

448 11 operator != 0 4 801 20 URLSpec::operator != 0 1 41 0
61
inline bool URLSpec::operator !=(URLSpec const &other) const;

449 10 operator < 0 4 801 19 URLSpec::operator < 0 1 42 0
60
inline bool URLSpec::operator <(URLSpec const &other) const;

450 10 compare_to 0 4 801 19 URLSpec::compare_to 0 1 43 158
/**
 * Returns a number less than zero if this URLSpec sorts before the other one,
 * greater than zero if it sorts after, or zero if they are equivalent.
 */
52
int URLSpec::compare_to(URLSpec const &other) const;

451 8 get_hash 0 4 801 17 URLSpec::get_hash 0 1 44 10
/**
 *
 */
42
std::size_t URLSpec::get_hash(void) const;

452 10 has_scheme 0 4 801 19 URLSpec::has_scheme 0 1 45 90
/**
 * Returns true if the URL specifies a scheme (e.g.  "http:"), false
 * otherwise.
 */
44
inline bool URLSpec::has_scheme(void) const;

453 13 has_authority 0 4 801 22 URLSpec::has_authority 0 1 46 124
/**
 * Returns true if the URL specifies an authority (this includes username,
 * server, and/or port), false otherwise.
 */
47
inline bool URLSpec::has_authority(void) const;

454 12 has_username 0 4 801 21 URLSpec::has_username 0 1 47 94
/**
 * Returns true if the URL specifies a username (and/or password), false
 * otherwise.
 */
46
inline bool URLSpec::has_username(void) const;

455 10 has_server 0 4 801 19 URLSpec::has_server 0 1 48 76
/**
 * Returns true if the URL specifies a server name, false otherwise.
 */
44
inline bool URLSpec::has_server(void) const;

456 8 has_port 0 4 801 17 URLSpec::has_port 0 1 49 76
/**
 * Returns true if the URL specifies a port number, false otherwise.
 */
42
inline bool URLSpec::has_port(void) const;

457 8 has_path 0 4 801 17 URLSpec::has_path 0 1 50 146
/**
 * Returns true if the URL includes a path specification (that is, the
 * particular filename on the server to retrieve), false otherwise.
 */
42
inline bool URLSpec::has_path(void) const;

458 9 has_query 0 4 801 18 URLSpec::has_query 0 1 51 83
/**
 * Returns true if the URL includes a query specification, false otherwise.
 */
43
inline bool URLSpec::has_query(void) const;

459 10 get_scheme 0 4 801 19 URLSpec::get_scheme 0 1 52 97
/**
 * Returns the scheme specified by the URL, or empty string if no scheme is
 * specified.
 */
44
std::string URLSpec::get_scheme(void) const;

460 13 get_authority 0 4 801 22 URLSpec::get_authority 0 1 53 149
/**
 * Returns the authority specified by the URL (this includes username, server,
 * and/or port), or empty string if no authority is specified.
 */
54
inline std::string URLSpec::get_authority(void) const;

461 12 get_username 0 4 801 21 URLSpec::get_username 0 1 54 194
/**
 * Returns the username specified by the URL, if any.  This might also include
 * a password, e.g.  "username:password", although putting a password on the
 * URL is probably a bad idea.
 */
53
inline std::string URLSpec::get_username(void) const;

462 10 get_server 0 4 801 19 URLSpec::get_server 0 1 55 137
/**
 * Returns the server name specified by the URL, if any.  In case of an IPv6
 * address, does not include the enclosing brackets.
 */
51
inline std::string URLSpec::get_server(void) const;

463 12 get_port_str 0 4 801 21 URLSpec::get_port_str 0 1 56 204
/**
 * Returns the port specified by the URL as a string, or the empty string if
 * no port is specified.  Compare this with get_port(), which returns a
 * default port number if no port is specified.
 */
53
inline std::string URLSpec::get_port_str(void) const;

464 8 get_port 0 4 801 17 URLSpec::get_port 0 1 57 97
/**
 * Returns the port number specified by the URL, or the default port if not
 * specified.
 */
39
uint16_t URLSpec::get_port(void) const;

465 19 get_server_and_port 0 4 801 28 URLSpec::get_server_and_port 0 1 58 298
/**
 * Returns a string consisting of the server name, followed by a colon,
 * followed by the port number.  If the port number is not explicitly given in
 * the URL, this string will include the implicit port number.
 * If the server is an IPv6 address, it will be enclosed in square brackets.
 */
53
std::string URLSpec::get_server_and_port(void) const;

466 15 is_default_port 0 4 801 24 URLSpec::is_default_port 0 1 59 181
/**
 * Returns true if the port number encoded in this URL is the default port
 * number for the scheme (or if there is no port number), or false if it is a
 * nonstandard port.
 */
42
bool URLSpec::is_default_port(void) const;

467 27 get_default_port_for_scheme 0 4 801 36 URLSpec::get_default_port_for_scheme 0 1 60 106
/**
 * Returns the default port number for the indicated scheme, or 0 if there is
 * no known default.
 */
75
static int URLSpec::get_default_port_for_scheme(std::string const &scheme);

468 8 get_path 0 4 801 17 URLSpec::get_path 0 1 61 81
/**
 * Returns the path specified by the URL, or "/" if no path is specified.
 */
42
std::string URLSpec::get_path(void) const;

469 9 get_query 0 4 801 18 URLSpec::get_query 0 1 62 95
/**
 * Returns the query specified by the URL, or empty string if no query is
 * specified.
 */
50
inline std::string URLSpec::get_query(void) const;

470 18 get_path_and_query 0 4 801 27 URLSpec::get_path_and_query 0 1 63 106
/**
 * Returns the path (or "/" if no path is specified), followed by the query if
 * it is specified.
 */
52
std::string URLSpec::get_path_and_query(void) const;

471 6 is_ssl 0 4 801 15 URLSpec::is_ssl 0 1 64 115
/**
 * Returns true if the URL's scheme specifies an SSL-secured protocol such as
 * https, or false otherwise.
 */
40
inline bool URLSpec::is_ssl(void) const;

472 7 get_url 0 4 801 16 URLSpec::get_url 0 1 65 50
/**
 * Returns the complete URL specification.
 */
55
inline std::string const &URLSpec::get_url(void) const;

473 10 set_scheme 0 4 801 19 URLSpec::set_scheme 0 1 66 61
/**
 * Replaces the scheme part of the URL specification.
 */
52
void URLSpec::set_scheme(std::string const &scheme);

474 13 set_authority 0 4 801 22 URLSpec::set_authority 0 1 67 114
/**
 * Replaces the authority part of the URL specification.  This includes the
 * username, server, and port.
 */
58
void URLSpec::set_authority(std::string const &authority);

475 12 set_username 0 4 801 21 URLSpec::set_username 0 1 68 63
/**
 * Replaces the username part of the URL specification.
 */
56
void URLSpec::set_username(std::string const &username);

476 10 set_server 0 4 801 19 URLSpec::set_server 0 1 69 174
/**
 * Replaces the server part of the URL specification.
 * Unlike set_server_and_port, this method does not require IPv6 addresses to
 * be enclosed in square brackets.
 */
52
void URLSpec::set_server(std::string const &server);

477 8 set_port 0 4 801 17 URLSpec::set_port 0 2 70 71 152
/**
 * Replaces the port part of the URL specification.
 */

/**
 * Replaces the port part of the URL specification, given a numeric port
 * number.
 */
87
void URLSpec::set_port(std::string const &port);
void URLSpec::set_port(uint16_t port);

478 19 set_server_and_port 0 4 801 28 URLSpec::set_server_and_port 0 1 72 254
/**
 * Replaces the server and port parts of the URL specification simultaneously.
 * The input string should be of the form "server:port", or just "server" to
 * make the port number implicit.
 * Any IPv6 address must be enclosed in square brackets.
 */
70
void URLSpec::set_server_and_port(std::string const &server_and_port);

479 8 set_path 0 4 801 17 URLSpec::set_path 0 1 73 59
/**
 * Replaces the path part of the URL specification.
 */
48
void URLSpec::set_path(std::string const &path);

480 9 set_query 0 4 801 18 URLSpec::set_query 0 1 74 60
/**
 * Replaces the query part of the URL specification.
 */
50
void URLSpec::set_query(std::string const &query);

481 7 set_url 0 4 801 16 URLSpec::set_url 0 1 75 191
/**
 * Completely replaces the URL with the indicated string.  If
 * server_name_expected is true, it is a hint that an undecorated URL is
 * probably a server name, not a local filename.
 */
81
void URLSpec::set_url(std::string const &url, bool server_name_expected = false);

482 17 operator typecast 0 132 801 26 URLSpec::operator typecast 0 1 87 0
48
inline operator std::string const &(void) const;

483 5 c_str 0 4 801 14 URLSpec::c_str 0 1 76 10
/**
 *
 */
46
inline char const *URLSpec::c_str(void) const;

484 5 empty 0 4 801 14 URLSpec::empty 0 1 77 98
/**
 * Returns false if the URLSpec is valid (not empty), or true if it is an
 * empty string.
 */
39
inline bool URLSpec::empty(void) const;

485 22 operator typecast bool 0 132 801 31 URLSpec::operator typecast bool 0 1 88 0
34
inline operator bool (void) const;

486 6 length 0 4 801 15 URLSpec::length 0 1 78 10
/**
 *
 */
47
inline std::size_t URLSpec::length(void) const;

487 4 size 0 4 801 13 URLSpec::size 0 1 79 10
/**
 *
 */
45
inline std::size_t URLSpec::size(void) const;

488 11 operator [] 0 4 801 20 URLSpec::operator [] 0 1 80 0
54
inline char URLSpec::operator [](std::size_t n) const;

489 5 input 0 4 801 14 URLSpec::input 0 1 81 10
/**
 *
 */
38
bool URLSpec::input(std::istream &in);

490 6 output 0 4 801 15 URLSpec::output 0 1 82 10
/**
 *
 */
46
void URLSpec::output(std::ostream &out) const;

491 5 quote 0 4 801 14 URLSpec::quote 0 1 83 313
/**
 * Returns the source string with all "unsafe" characters quoted, making a
 * string suitable for placing in a URL.  Letters, digits, and the underscore,
 * comma, period, and hyphen characters, as well as any included in the safe
 * string, are left alone; all others are converted to hex representation.
 */
92
static std::string URLSpec::quote(std::string const &source, std::string const &safe = "/");

492 10 quote_plus 0 4 801 19 URLSpec::quote_plus 0 1 84 100
/**
 * Behaves like quote() with the additional behavior of replacing spaces with
 * plus signs.
 */
97
static std::string URLSpec::quote_plus(std::string const &source, std::string const &safe = "/");

493 7 unquote 0 4 801 16 URLSpec::unquote 0 1 85 121
/**
 * Reverses the operation of quote(): converts escaped characters of the form
 * "%xx" to their ascii equivalent.
 */
63
static std::string URLSpec::unquote(std::string const &source);

494 12 unquote_plus 0 4 801 21 URLSpec::unquote_plus 0 1 86 169
/**
 * Reverses the operation of quote_plus(): converts escaped characters of the
 * form "%xx" to their ascii equivalent, and also converts plus signs to
 * spaces.
 */
68
static std::string URLSpec::unquote_plus(std::string const &source);

495 8 ~URLSpec 0 4 801 17 URLSpec::~URLSpec 0 0 0
24
URLSpec::~URLSpec(void);

496 8 HTTPEnum 0 4 807 18 HTTPEnum::HTTPEnum 0 2 89 90 0
97
inline HTTPEnum::HTTPEnum(void) = default;
inline HTTPEnum::HTTPEnum(HTTPEnum const &) = default;

497 9 ~HTTPEnum 0 4 807 19 HTTPEnum::~HTTPEnum 0 0 0
26
HTTPEnum::~HTTPEnum(void);

498 8 HTTPDate 0 4 810 18 HTTPDate::HTTPDate 0 4 91 92 93 94 158
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Decodes the string into a sensible date.  Returns 0 (!is_valid()) if the
 * string cannot be correctly decoded.
 */
168
inline HTTPDate::HTTPDate(void);
inline HTTPDate::HTTPDate(time_t time);
HTTPDate::HTTPDate(std::string const &format);
inline HTTPDate::HTTPDate(HTTPDate const &copy);

499 10 operator = 0 4 810 20 HTTPDate::operator = 0 1 95 0
55
inline void HTTPDate::operator =(HTTPDate const &copy);

500 3 now 0 4 810 13 HTTPDate::now 0 1 96 73
/**
 * Returns an HTTPDate that represents the current time and date.
 */
43
static inline HTTPDate HTTPDate::now(void);

501 8 is_valid 0 4 810 18 HTTPDate::is_valid 0 1 97 141
/**
 * Returns true if the date is meaningful, or false if it is -1 (which
 * generally indicates the source string could not be parsed.)
 */
43
inline bool HTTPDate::is_valid(void) const;

502 10 get_string 0 4 810 20 HTTPDate::get_string 0 1 98 10
/**
 *
 */
45
std::string HTTPDate::get_string(void) const;

503 8 get_time 0 4 810 18 HTTPDate::get_time 0 1 99 48
/**
 * Returns the date as a C time_t value.
 */
45
inline time_t HTTPDate::get_time(void) const;

504 11 operator == 0 4 810 21 HTTPDate::operator == 0 1 100 0
63
inline bool HTTPDate::operator ==(HTTPDate const &other) const;

505 11 operator != 0 4 810 21 HTTPDate::operator != 0 1 101 0
63
inline bool HTTPDate::operator !=(HTTPDate const &other) const;

506 10 operator < 0 4 810 20 HTTPDate::operator < 0 1 102 0
62
inline bool HTTPDate::operator <(HTTPDate const &other) const;

507 10 operator > 0 4 810 20 HTTPDate::operator > 0 1 103 0
62
inline bool HTTPDate::operator >(HTTPDate const &other) const;

508 10 compare_to 0 4 810 20 HTTPDate::compare_to 0 1 104 159
/**
 * Returns a number less than zero if this HTTPDate sorts before the other
 * one, greater than zero if it sorts after, or zero if they are equivalent.
 */
61
inline int HTTPDate::compare_to(HTTPDate const &other) const;

509 11 operator += 0 4 810 21 HTTPDate::operator += 0 1 105 0
47
inline void HTTPDate::operator +=(int seconds);

510 11 operator -= 0 4 810 21 HTTPDate::operator -= 0 1 106 0
47
inline void HTTPDate::operator -=(int seconds);

511 10 operator + 0 4 810 20 HTTPDate::operator + 0 1 107 0
56
inline HTTPDate HTTPDate::operator +(int seconds) const;

512 10 operator - 0 4 810 20 HTTPDate::operator - 0 2 108 109 0
118
inline HTTPDate HTTPDate::operator -(int seconds) const;
inline int HTTPDate::operator -(HTTPDate const &other) const;

513 5 input 0 4 810 15 HTTPDate::input 0 1 110 10
/**
 *
 */
39
bool HTTPDate::input(std::istream &in);

514 6 output 0 4 810 16 HTTPDate::output 0 1 111 10
/**
 *
 */
47
void HTTPDate::output(std::ostream &out) const;

515 9 ~HTTPDate 0 4 810 19 HTTPDate::~HTTPDate 0 0 0
26
HTTPDate::~HTTPDate(void);

516 10 HTTPCookie 0 4 811 22 HTTPCookie::HTTPCookie 0 4 112 113 114 115 418
/**
 * Constructs an empty cookie.
 */

/**
 * Constructs a cookie according to the indicated string, presumably the tag
 * of a Set-Cookie header.  There is no way to detect a formatting error in
 * the string with this constructor.
 */

/**
 * Constructs a cookie with the indicated name, path, and domain values, but
 * no other data.  This is most useful for looking up an existing cookie in
 * the HTTPClient.
 */
301
inline HTTPCookie::HTTPCookie(void);
inline explicit HTTPCookie::HTTPCookie(std::string const &format, URLSpec const &url);
inline explicit HTTPCookie::HTTPCookie(std::string const &name, std::string const &path, std::string const &domain);
inline HTTPCookie::HTTPCookie(HTTPCookie const &) = default;

517 11 ~HTTPCookie 0 4 811 23 HTTPCookie::~HTTPCookie 0 0 10
/**
 *
 */
37
inline HTTPCookie::~HTTPCookie(void);

518 8 set_name 0 4 811 20 HTTPCookie::set_name 0 1 116 10
/**
 *
 */
58
inline void HTTPCookie::set_name(std::string const &name);

519 8 get_name 0 4 811 20 HTTPCookie::get_name 0 1 117 93
/**
 * Returns the name of the cookie.  This is the key value specified by the
 * server.
 */
59
inline std::string const &HTTPCookie::get_name(void) const;

520 9 set_value 0 4 811 21 HTTPCookie::set_value 0 1 118 10
/**
 *
 */
60
inline void HTTPCookie::set_value(std::string const &value);

521 9 get_value 0 4 811 21 HTTPCookie::get_value 0 1 119 139
/**
 * Returns the value of the cookie.  This is the arbitrary string associated
 * with the cookie's name, as specified by the server.
 */
60
inline std::string const &HTTPCookie::get_value(void) const;

522 10 set_domain 0 4 811 22 HTTPCookie::set_domain 0 1 120 10
/**
 *
 */
62
inline void HTTPCookie::set_domain(std::string const &domain);

523 10 get_domain 0 4 811 22 HTTPCookie::get_domain 0 1 121 10
/**
 *
 */
61
inline std::string const &HTTPCookie::get_domain(void) const;

524 8 set_path 0 4 811 20 HTTPCookie::set_path 0 1 122 10
/**
 *
 */
58
inline void HTTPCookie::set_path(std::string const &path);

525 8 get_path 0 4 811 20 HTTPCookie::get_path 0 1 123 99
/**
 * Returns the prefix of the URL paths on the server for which this cookie
 * will be sent.
 */
59
inline std::string const &HTTPCookie::get_path(void) const;

526 11 set_expires 0 4 811 23 HTTPCookie::set_expires 0 1 124 10
/**
 *
 */
61
inline void HTTPCookie::set_expires(HTTPDate const &expires);

527 13 clear_expires 0 4 811 25 HTTPCookie::clear_expires 0 1 125 53
/**
 * Removes the expiration date on the cookie.
 */
44
inline void HTTPCookie::clear_expires(void);

528 11 has_expires 0 4 811 23 HTTPCookie::has_expires 0 1 126 78
/**
 * Returns true if the cookie has an expiration date, false otherwise.
 */
48
inline bool HTTPCookie::has_expires(void) const;

529 11 get_expires 0 4 811 23 HTTPCookie::get_expires 0 1 127 102
/**
 * Returns the expiration date of the cookie if it is set, or an invalid date
 * if it is not.
 */
52
inline HTTPDate HTTPCookie::get_expires(void) const;

530 10 set_secure 0 4 811 22 HTTPCookie::set_secure 0 1 128 10
/**
 *
 */
46
inline void HTTPCookie::set_secure(bool flag);

531 10 get_secure 0 4 811 22 HTTPCookie::get_secure 0 1 129 129
/**
 * Returns true if the server has indicated this is a "secure" cookie which
 * should only be sent over an HTTPS channel.
 */
47
inline bool HTTPCookie::get_secure(void) const;

532 10 operator < 0 4 811 22 HTTPCookie::operator < 0 1 130 0
59
bool HTTPCookie::operator <(HTTPCookie const &other) const;

533 11 update_from 0 4 811 23 HTTPCookie::update_from 0 1 131 358
/**
 * Assuming the operator < method, above, has already evaluated these two
 * cookies as equal, then assign the remaining values (value, expiration date,
 * secure flag) from the indicated cookie.  This is guaranteed not to change
 * the ordering of the cookie in a set, and so can be used to update an
 * existing cookie within a set with new values.
 */
54
void HTTPCookie::update_from(HTTPCookie const &other);

534 16 parse_set_cookie 0 4 811 28 HTTPCookie::parse_set_cookie 0 1 132 218
/**
 * Separates out the parameter/value pairs of the Set-Cookie header and
 * assigns the values of the cookie appropriate.  Returns true if the header
 * is parsed correctly, false if something is not understood.
 */
81
bool HTTPCookie::parse_set_cookie(std::string const &format, URLSpec const &url);

535 10 is_expired 0 4 811 22 HTTPCookie::is_expired 0 1 133 105
/**
 * Returns true if the cookie's expiration date is before the indicated date,
 * false otherwise.
 */
80
inline bool HTTPCookie::is_expired(HTTPDate const &now = HTTPDate::now()) const;

536 11 matches_url 0 4 811 23 HTTPCookie::matches_url 0 1 134 112
/**
 * Returns true if the cookie is appropriate to send with the indicated URL
 * request, false otherwise.
 */
55
bool HTTPCookie::matches_url(URLSpec const &url) const;

537 6 output 0 4 811 18 HTTPCookie::output 0 1 135 10
/**
 *
 */
49
void HTTPCookie::output(std::ostream &out) const;

538 10 HTTPClient 0 4 812 22 HTTPClient::HTTPClient 0 2 136 137 22
/**
 *
 */

/**
 *
 */
77
HTTPClient::HTTPClient(void);
HTTPClient::HTTPClient(HTTPClient const &copy);

539 10 operator = 0 4 812 22 HTTPClient::operator = 0 1 138 0
52
void HTTPClient::operator =(HTTPClient const &copy);

540 16 init_random_seed 0 4 812 28 HTTPClient::init_random_seed 0 1 139 561
/**
 * This may be called once, presumably at the beginning of an application, to
 * initialize OpenSSL's random seed.  On Windows, it is particularly important
 * to call this at startup if you are going to be performing any https
 * operations or otherwise use encryption, since the Windows algorithm for
 * getting a random seed takes 2-3 seconds at startup, but can take 30 seconds
 * or more after you have opened a 3-D graphics window and started rendering.
 *
 * There is no harm in calling this method multiple times, or in not calling
 * it at all.
 */
47
static void HTTPClient::init_random_seed(void);

541 14 set_proxy_spec 0 4 812 26 HTTPClient::set_proxy_spec 0 1 140 511
/**
 * Specifies the complete set of proxies to use for all schemes.  This is
 * either a semicolon-delimited set of hostname:ports, or a semicolon-
 * delimited set of pairs of the form "scheme=hostname:port", or a
 * combination.  Use the keyword DIRECT, or an empty string, to represent a
 * direct connection.  A particular scheme and/or proxy host may be listed
 * more than once.  This is a convenience function that can be used in place
 * of explicit calls to add_proxy() for each scheme/proxy pair.
 */
63
void HTTPClient::set_proxy_spec(std::string const &proxy_spec);

542 14 get_proxy_spec 0 4 812 26 HTTPClient::get_proxy_spec 0 1 141 371
/**
 * Returns the complete set of proxies to use for all schemes.  This is a
 * string of the form specified by set_proxy_spec(), above.  Note that the
 * string returned by this function may not be exactly the same as the string
 * passed into set_proxy_spec(), since the string is regenerated from the
 * internal storage structures and may therefore be reordered.
 */
51
std::string HTTPClient::get_proxy_spec(void) const;

543 20 set_direct_host_spec 0 4 812 32 HTTPClient::set_direct_host_spec 0 1 142 197
/**
 * Specifies the set of hosts that should be connected to directly, without
 * using a proxy.  This is a semicolon-separated list of hostnames that may
 * contain wildcard characters ("*").
 */
75
void HTTPClient::set_direct_host_spec(std::string const &direct_host_spec);

544 20 get_direct_host_spec 0 4 812 32 HTTPClient::get_direct_host_spec 0 1 143 189
/**
 * Returns the set of hosts that should be connected to directly, without
 * using a proxy, as a semicolon-separated list of hostnames that may contain
 * wildcard characters ("*").
 */
57
std::string HTTPClient::get_direct_host_spec(void) const;

545 18 set_try_all_direct 0 4 812 30 HTTPClient::set_try_all_direct 0 1 144 306
/**
 * If this is set true, then after a connection attempt through a proxy fails,
 * we always try a direct connection, regardless of whether the host is listed
 * on the direct_host_spec list.  If this is false, a direct attempt is not
 * made when we have a proxy in effect, even if the proxy fails.
 */
64
inline void HTTPClient::set_try_all_direct(bool try_all_direct);

546 18 get_try_all_direct 0 4 812 30 HTTPClient::get_try_all_direct 0 1 145 134
/**
 * Returns whether a failed connection through a proxy will be followed up by
 * a direct connection attempt, false otherwise.
 */
55
inline bool HTTPClient::get_try_all_direct(void) const;

547 11 clear_proxy 0 4 812 23 HTTPClient::clear_proxy 0 1 146 128
/**
 * Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be
 * made to build up the set of proxy servers.
 */
35
void HTTPClient::clear_proxy(void);

548 9 add_proxy 0 4 812 21 HTTPClient::add_proxy 0 1 147 271
/**
 * Adds the indicated proxy host as a proxy for communications on the given
 * scheme.  Usually the scheme is "http" or "https".  It may be the empty
 * string to indicate a general proxy.  The proxy string may be the empty URL
 * to indicate a direct connection.
 */
76
void HTTPClient::add_proxy(std::string const &scheme, URLSpec const &proxy);

549 17 clear_direct_host 0 4 812 29 HTTPClient::clear_direct_host 0 1 148 178
/**
 * Resets the set of direct hosts to empty.  Subsequent calls to
 * add_direct_host() may be made to build up the list of hosts that do not
 * require a proxy connection.
 */
41
void HTTPClient::clear_direct_host(void);

550 15 add_direct_host 0 4 812 27 HTTPClient::add_direct_host 0 1 149 223
/**
 * Adds the indicated name to the set of hostnames that are connected to
 * directly, without using a proxy.  This name may be either a DNS name or an
 * IP address, and it may include the * as a wildcard character.
 */
62
void HTTPClient::add_direct_host(std::string const &hostname);

551 19 get_proxies_for_url 0 4 812 31 HTTPClient::get_proxies_for_url 0 1 150 621
/**
 * Fills up the indicated vector with the list of URLSpec objects, in the
 * order in which they should be tried, that are appropriate proxies to try
 * for the indicated URL.  The empty URL is returned for a direct connection.
 *
 * It is the user's responsibility to empty this vector before calling this
 * method; otherwise, the proxy URL's will simply be appended to the existing
 * list.
 */

/**
 * Returns a semicolon-delimited list of proxies, in the order in which they
 * should be tried, that are appropriate for the indicated URL.  The keyword
 * DIRECT indicates a direct connection should be tried.
 */
70
std::string HTTPClient::get_proxies_for_url(URLSpec const &url) const;

552 12 set_username 0 4 812 24 HTTPClient::set_username 0 1 151 433
/**
 * Specifies the username:password string corresponding to a particular server
 * and/or realm, when demanded by the server.  Either or both of the server or
 * realm may be empty; if so, they match anything.  Also, the server may be
 * set to the special string `"*proxy"`, which will match any proxy server.
 *
 * If the username is set to the empty string, this clears the password for
 * the particular server/realm pair.
 */
112
void HTTPClient::set_username(std::string const &server, std::string const &realm, std::string const &username);

553 12 get_username 0 4 812 24 HTTPClient::get_username 0 1 152 144
/**
 * Returns the username:password string set for this server/realm pair, or
 * empty string if nothing has been set.  See set_username().
 */
96
std::string HTTPClient::get_username(std::string const &server, std::string const &realm) const;

554 10 set_cookie 0 4 812 22 HTTPClient::set_cookie 0 1 153 116
/**
 * Stores the indicated cookie in the client's list of cookies, as if it had
 * been received from a server.
 */
54
void HTTPClient::set_cookie(HTTPCookie const &cookie);

555 12 clear_cookie 0 4 812 24 HTTPClient::clear_cookie 0 1 154 175
/**
 * Removes the cookie with the matching domain/path/name from the client's
 * list of cookies.  Returns true if it was removed, false if the cookie was
 * not matched.
 */
56
bool HTTPClient::clear_cookie(HTTPCookie const &cookie);

556 17 clear_all_cookies 0 4 812 29 HTTPClient::clear_all_cookies 0 1 155 58
/**
 * Removes the all stored cookies from the client.
 */
41
void HTTPClient::clear_all_cookies(void);

557 10 has_cookie 0 4 812 22 HTTPClient::has_cookie 0 1 156 124
/**
 * Returns true if there is a cookie in the client matching the given cookie's
 * domain/path/name, false otherwise.
 */
60
bool HTTPClient::has_cookie(HTTPCookie const &cookie) const;

558 10 get_cookie 0 4 812 22 HTTPClient::get_cookie 0 1 157 163
/**
 * Looks up and returns the cookie in the client matching the given cookie's
 * domain/path/name.  If there is no matching cookie, returns an empty cookie.
 */
66
HTTPCookie HTTPClient::get_cookie(HTTPCookie const &cookie) const;

559 17 copy_cookies_from 0 4 812 29 HTTPClient::copy_cookies_from 0 1 158 179
/**
 * Copies all the cookies from the indicated HTTPClient into this one.
 * Existing cookies in this client are not affected, unless they are shadowed
 * by the new cookies.
 */
60
void HTTPClient::copy_cookies_from(HTTPClient const &other);

560 13 write_cookies 0 4 812 25 HTTPClient::write_cookies 0 1 159 172
/**
 * Outputs the complete list of cookies stored on the client, for all domains,
 * including the expired cookies (which will normally not be sent back to a
 * host).
 */
56
void HTTPClient::write_cookies(std::ostream &out) const;

561 12 send_cookies 0 4 812 24 HTTPClient::send_cookies 0 1 160 192
/**
 * Writes to the indicated ostream a "Cookie" header line for sending the
 * cookies appropriate to the indicated URL along with an HTTP request.  This
 * also removes expired cookies.
 */
69
void HTTPClient::send_cookies(std::ostream &out, URLSpec const &url);

562 31 set_client_certificate_filename 0 4 812 43 HTTPClient::set_client_certificate_filename 0 1 161 250
/**
 * Sets the filename of the pem-formatted file that will be read for the
 * client public and private keys if an SSL server requests a certificate.
 * Either this or set_client_certificate_pem() may be used to specify a client
 * certificate.
 */
82
inline void HTTPClient::set_client_certificate_filename(Filename const &filename);

563 26 set_client_certificate_pem 0 4 812 38 HTTPClient::set_client_certificate_pem 0 1 162 264
/**
 * Sets the pem-formatted contents of the certificate that will be parsed for
 * the client public and private keys if an SSL server requests a certificate.
 * Either this or set_client_certificate_filename() may be used to specify a
 * client certificate.
 */
75
inline void HTTPClient::set_client_certificate_pem(std::string const &pem);

564 33 set_client_certificate_passphrase 0 4 812 45 HTTPClient::set_client_certificate_passphrase 0 1 163 160
/**
 * Sets the passphrase used to decrypt the private key in the certificate
 * named by set_client_certificate_filename() or set_client_certificate_pem().
 */
89
inline void HTTPClient::set_client_certificate_passphrase(std::string const &passphrase);

565 23 load_client_certificate 0 4 812 35 HTTPClient::load_client_certificate 0 1 164 376
/**
 * Attempts to load the certificate named by set_client_certificate_filename()
 * immediately, and returns true if successful, false otherwise.
 *
 * Normally this need not be explicitly called, since it will be called
 * automatically if the server requests a certificate, but it may be useful to
 * determine ahead of time if the certificate can be loaded correctly.
 */
47
bool HTTPClient::load_client_certificate(void);

566 43 add_preapproved_server_certificate_filename 0 4 812 55 HTTPClient::add_preapproved_server_certificate_filename 0 1 165 547
/**
 * Adds the certificate defined in the indicated PEM filename as a "pre-
 * approved" certificate for the indicated server, defined by the hostname and
 * port (only) from the given URL.
 *
 * If the server offers this particular certificate on a secure connection, it
 * will be accepted without question.  This is particularly useful for
 * communicating with a server using a known self-signed certificate.
 *
 * See also the similar add_preapproved_server_certificate_pem(), and the
 * weaker add_preapproved_server_certificate_name().
 */
107
bool HTTPClient::add_preapproved_server_certificate_filename(URLSpec const &url, Filename const &filename);

567 38 add_preapproved_server_certificate_pem 0 4 812 50 HTTPClient::add_preapproved_server_certificate_pem 0 1 166 577
/**
 * Adds the certificate defined in the indicated data string, formatted as a
 * PEM block, as a "pre-approved" certificate for the indicated server,
 * defined by the hostname and port (only) from the given URL.
 *
 * If the server offers this particular certificate on a secure connection, it
 * will be accepted without question.  This is particularly useful for
 * communicating with a server using a known self-signed certificate.
 *
 * See also the similar add_preapproved_server_certificate_filename(), and the
 * weaker add_preapproved_server_certificate_name().
 */
100
bool HTTPClient::add_preapproved_server_certificate_pem(URLSpec const &url, std::string const &pem);

568 39 add_preapproved_server_certificate_name 0 4 812 51 HTTPClient::add_preapproved_server_certificate_name 0 1 167 888
/**
 * Adds the certificate *name* only, as a "pre-approved" certificate name for
 * the indicated server, defined by the hostname and port (only) from the
 * given URL.
 *
 * This is a weaker function than
 * add_preapproved_server_certificate_filename().  This checks only the
 * subject name of the certificate, without checking for a particular
 * certificate by key.  This means that a variety of server certificates may
 * match the indicated name.
 *
 * Because this is a weaker verification, it only applies to server
 * certificates that are signed by a recognized certificate authority.  Thus,
 * it cannot be used to pre-approve self-signed certificates, but it can be
 * used to accept a server certificate offered by a different hostname than
 * the one in the cert itself.
 *
 * The certificate name should be formatted in the form
 * type0=value0/type1=value1/type2=...
 */
102
bool HTTPClient::add_preapproved_server_certificate_name(URLSpec const &url, std::string const &name);

569 37 clear_preapproved_server_certificates 0 4 812 49 HTTPClient::clear_preapproved_server_certificates 0 1 168 92
/**
 * Removes all preapproved server certificates for the indicated server and
 * port.
 */
75
void HTTPClient::clear_preapproved_server_certificates(URLSpec const &url);

570 41 clear_all_preapproved_server_certificates 0 4 812 53 HTTPClient::clear_all_preapproved_server_certificates 0 1 169 71
/**
 * Removes all preapproved server certificates for all servers.
 */
65
void HTTPClient::clear_all_preapproved_server_certificates(void);

571 16 set_http_version 0 4 812 28 HTTPClient::set_http_version 0 1 170 221
/**
 * Specifies the version of HTTP that the client uses to identify itself to
 * the server.  The default is HV_11, or HTTP 1.0; you can set this to HV_10
 * (HTTP 1.0) to request the server use the older interface.
 */
72
inline void HTTPClient::set_http_version(HTTPEnum::HTTPVersion version);

572 16 get_http_version 0 4 812 28 HTTPClient::get_http_version 0 1 171 93
/**
 * Returns the client's current setting for HTTP version.  See
 * set_http_version().
 */
70
inline HTTPEnum::HTTPVersion HTTPClient::get_http_version(void) const;

573 23 get_http_version_string 0 4 812 35 HTTPClient::get_http_version_string 0 1 172 99
/**
 * Returns the current HTTP version setting as a string, e.g.  "HTTP/1.0" or
 * "HTTP/1.1".
 */
60
std::string HTTPClient::get_http_version_string(void) const;

574 25 parse_http_version_string 0 4 812 37 HTTPClient::parse_http_version_string 0 1 173 193
/**
 * Matches the string representing a particular HTTP version against any of
 * the known versions and returns the appropriate enumerated value, or
 * HV_other if the version is unknown.
 */
95
static HTTPEnum::HTTPVersion HTTPClient::parse_http_version_string(std::string const &version);

575 17 load_certificates 0 4 812 29 HTTPClient::load_certificates 0 1 174 263
/**
 * Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and
 * -----END CERTIFICATE-----) from the indicated file and makes them known as
 * trusted public keys for validating future connections.  Returns true on
 * success, false otherwise.
 */
61
bool HTTPClient::load_certificates(Filename const &filename);

576 14 set_verify_ssl 0 4 812 26 HTTPClient::set_verify_ssl 0 1 175 263
/**
 * Specifies whether the client will insist on verifying the identity of the
 * servers it connects to via SSL (that is, https).
 *
 * The parameter value is an enumerated type which indicates the level of
 * security to which the client will insist upon.
 */
73
inline void HTTPClient::set_verify_ssl(HTTPClient::VerifySSL verify_ssl);

577 14 get_verify_ssl 0 4 812 26 HTTPClient::get_verify_ssl 0 1 176 157
/**
 * Returns whether the client will insist on verifying the identity of the
 * servers it connects to via SSL (that is, https).  See set_verify_ssl().
 */
68
inline HTTPClient::VerifySSL HTTPClient::get_verify_ssl(void) const;

578 15 set_cipher_list 0 4 812 27 HTTPClient::set_cipher_list 0 1 177 404
/**
 * Specifies the set of ciphers that are to be made available for SSL
 * connections.  This is a string as described in the ciphers(1) man page of
 * the OpenSSL documentation (or see
 * https://www.openssl.org/docs/man1.1.1/man1/ciphers.html ).  If this isn't
 * specified, the default is provided by the Config file.  You may also specify
 * "DEFAULT" to use the built-in OpenSSL default value.
 */
72
inline void HTTPClient::set_cipher_list(std::string const &cipher_list);

579 15 get_cipher_list 0 4 812 27 HTTPClient::get_cipher_list 0 1 178 93
/**
 * Returns the set of ciphers as set by set_cipher_list().  See
 * set_cipher_list().
 */
66
inline std::string const &HTTPClient::get_cipher_list(void) const;

580 12 make_channel 0 4 812 24 HTTPClient::make_channel 0 1 179 763
/**
 * Returns a new HTTPChannel object that may be used for reading multiple
 * documents using the same connection, for greater network efficiency than
 * calling HTTPClient::get_document() repeatedly (which would force a new
 * connection for each document).
 *
 * Also, HTTPChannel has some additional, less common interface methods than
 * the basic interface methods that exist on HTTPClient; if you wish to call
 * any of these methods you must first obtain an HTTPChannel.
 *
 * Pass true for persistent_connection to gain this network efficiency.  If,
 * on the other hand, your intention is to use the channel to retrieve only
 * one document, then pass false to inform the server that we will be dropping
 * the connection after the first document.
 */
78
PointerTo< HTTPChannel > HTTPClient::make_channel(bool persistent_connection);

581 9 post_form 0 4 812 21 HTTPClient::post_form 0 1 180 262
/**
 * Posts form data to a particular URL and retrieves the response.  Returns a
 * new HTTPChannel object whether the document is successfully read or not;
 * you can test is_valid() and get_return_code() to determine whether the
 * document was retrieved.
 */
92
PointerTo< HTTPChannel > HTTPClient::post_form(URLSpec const &url, std::string const &body);

582 12 get_document 0 4 812 24 HTTPClient::get_document 0 1 181 233
/**
 * Opens the named document for reading.  Returns a new HTTPChannel object
 * whether the document is successfully read or not; you can test is_valid()
 * and get_return_code() to determine whether the document was retrieved.
 */
70
PointerTo< HTTPChannel > HTTPClient::get_document(URLSpec const &url);

583 10 get_header 0 4 812 22 HTTPClient::get_header 0 1 182 252
/**
 * Like get_document(), except only the header associated with the document is
 * retrieved.  This may be used to test for existence of the document; it
 * might also return the size of the document (if the server gives us this
 * information).
 */
68
PointerTo< HTTPChannel > HTTPClient::get_header(URLSpec const &url);

584 13 base64_encode 0 4 812 25 HTTPClient::base64_encode 0 1 183 222
/**
 * Implements HTTPAuthorization::base64_encode().  This is provided here just
 * as a convenient place to publish it for access by the scripting language;
 * C++ code should probably use HTTPAuthorization directly.
 */
74
static inline std::string HTTPClient::base64_encode(std::string const &s);

585 13 base64_decode 0 4 812 25 HTTPClient::base64_decode 0 1 184 222
/**
 * Implements HTTPAuthorization::base64_decode().  This is provided here just
 * as a convenient place to publish it for access by the scripting language;
 * C++ code should probably use HTTPAuthorization directly.
 */
74
static inline std::string HTTPClient::base64_decode(std::string const &s);

586 14 get_global_ptr 0 4 812 26 HTTPClient::get_global_ptr 0 1 185 49
/**
 * Returns the default global HTTPClient.
 */
52
static HTTPClient *HTTPClient::get_global_ptr(void);

587 13 HTTPEntityTag 0 4 815 28 HTTPEntityTag::HTTPEntityTag 0 4 186 187 188 189 259
/**
 *
 */

/**
 * This constructor accepts an explicit weak flag and a literal (not quoted)
 * tag string.
 */

/**
 *
 */

/**
 * This constructor accepts a string as formatted from an HTTP server (e.g.
 * the tag is quoted, with an optional W/ prefix.)
 */
233
inline HTTPEntityTag::HTTPEntityTag(void);
HTTPEntityTag::HTTPEntityTag(std::string const &text);
inline HTTPEntityTag::HTTPEntityTag(bool weak, std::string const &tag);
inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &copy);

588 10 operator = 0 4 815 25 HTTPEntityTag::operator = 0 1 190 0
65
inline void HTTPEntityTag::operator =(HTTPEntityTag const &copy);

589 7 is_weak 0 4 815 22 HTTPEntityTag::is_weak 0 1 191 255
/**
 * Returns true if the entity tag is marked as "weak". A consistent weak
 * entity tag does not guarantee that its resource has not changed in any way,
 * but it does promise that the resource has not changed in any semantically
 * meaningful way.
 */
47
inline bool HTTPEntityTag::is_weak(void) const;

590 7 get_tag 0 4 815 22 HTTPEntityTag::get_tag 0 1 192 47
/**
 * Returns the tag as a literal string.
 */
61
inline std::string const &HTTPEntityTag::get_tag(void) const;

591 10 get_string 0 4 815 25 HTTPEntityTag::get_string 0 1 193 126
/**
 * Returns the entity tag formatted for sending to an HTTP server (the tag is
 * quoted, with a conditional W prefix).
 */
50
std::string HTTPEntityTag::get_string(void) const;

592 12 strong_equiv 0 4 815 27 HTTPEntityTag::strong_equiv 0 1 194 115
/**
 * Returns true if the two tags have "strong" equivalence: they are the same
 * tag, and both are "strong".
 */
74
inline bool HTTPEntityTag::strong_equiv(HTTPEntityTag const &other) const;

593 10 weak_equiv 0 4 815 25 HTTPEntityTag::weak_equiv 0 1 195 121
/**
 * Returns true if the two tags have "weak" equivalence: they are the same
 * tag, and one or both may be "weak".
 */
72
inline bool HTTPEntityTag::weak_equiv(HTTPEntityTag const &other) const;

594 11 operator == 0 4 815 26 HTTPEntityTag::operator == 0 1 196 0
73
inline bool HTTPEntityTag::operator ==(HTTPEntityTag const &other) const;

595 11 operator != 0 4 815 26 HTTPEntityTag::operator != 0 1 197 0
73
inline bool HTTPEntityTag::operator !=(HTTPEntityTag const &other) const;

596 10 operator < 0 4 815 25 HTTPEntityTag::operator < 0 1 198 0
72
inline bool HTTPEntityTag::operator <(HTTPEntityTag const &other) const;

597 10 compare_to 0 4 815 25 HTTPEntityTag::compare_to 0 1 199 167
/**
 * Returns a number less than zero if this HTTPEntityTag sorts before the
 * other one, greater than zero if it sorts after, or zero if they are
 * equivalent.
 */
71
inline int HTTPEntityTag::compare_to(HTTPEntityTag const &other) const;

598 6 output 0 4 815 21 HTTPEntityTag::output 0 1 200 10
/**
 *
 */
59
inline void HTTPEntityTag::output(std::ostream &out) const;

599 14 ~HTTPEntityTag 0 4 815 29 HTTPEntityTag::~HTTPEntityTag 0 0 0
36
HTTPEntityTag::~HTTPEntityTag(void);

600 12 DocumentSpec 0 4 816 26 DocumentSpec::DocumentSpec 0 4 201 202 203 204 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
215
inline DocumentSpec::DocumentSpec(void);
inline DocumentSpec::DocumentSpec(std::string const &url);
inline DocumentSpec::DocumentSpec(URLSpec const &url);
inline DocumentSpec::DocumentSpec(DocumentSpec const &copy);

601 10 operator = 0 4 816 24 DocumentSpec::operator = 0 1 205 0
63
inline void DocumentSpec::operator =(DocumentSpec const &copy);

602 11 operator == 0 4 816 25 DocumentSpec::operator == 0 1 206 0
71
inline bool DocumentSpec::operator ==(DocumentSpec const &other) const;

603 11 operator != 0 4 816 25 DocumentSpec::operator != 0 1 207 0
71
inline bool DocumentSpec::operator !=(DocumentSpec const &other) const;

604 10 operator < 0 4 816 24 DocumentSpec::operator < 0 1 208 0
70
inline bool DocumentSpec::operator <(DocumentSpec const &other) const;

605 10 compare_to 0 4 816 24 DocumentSpec::compare_to 0 1 209 10
/**
 *
 */
62
int DocumentSpec::compare_to(DocumentSpec const &other) const;

606 7 set_url 0 4 816 21 DocumentSpec::set_url 0 1 210 311
/**
 * Changes the URL of the DocumentSpec without modifying its other properties.
 * Normally this would be a strange thing to do, because the tag and date are
 * usually strongly associated with the URL.  To get a DocumentSpec pointing
 * to a new URL, you would normally create a new DocumentSpec object.
 */
54
inline void DocumentSpec::set_url(URLSpec const &url);

607 7 get_url 0 4 816 21 DocumentSpec::get_url 0 1 211 49
/**
 * Retrieves the URL of the DocumentSpec.
 */
56
inline URLSpec const &DocumentSpec::get_url(void) const;

608 7 set_tag 0 4 816 21 DocumentSpec::set_tag 0 1 212 69
/**
 * Changes the identity tag associated with the DocumentSpec.
 */
60
inline void DocumentSpec::set_tag(HTTPEntityTag const &tag);

609 7 has_tag 0 4 816 21 DocumentSpec::has_tag 0 1 213 79
/**
 * Returns true if an identity tag is associated with the DocumentSpec.
 */
46
inline bool DocumentSpec::has_tag(void) const;

610 7 get_tag 0 4 816 21 DocumentSpec::get_tag 0 1 214 254
/**
 * Returns the identity tag associated with the DocumentSpec, if there is one.
 * It is an error to call this if has_tag() returns false.
 *
 * The identity tag is set by the HTTP server to uniquely refer to a
 * particular version of a document.
 */
62
inline HTTPEntityTag const &DocumentSpec::get_tag(void) const;

611 9 clear_tag 0 4 816 23 DocumentSpec::clear_tag 0 1 215 86
/**
 * Removes the identity tag associated with the DocumentSpec, if there is one.
 */
42
inline void DocumentSpec::clear_tag(void);

612 8 set_date 0 4 816 22 DocumentSpec::set_date 0 1 216 75
/**
 * Changes the last-modified date associated with the DocumentSpec.
 */
57
inline void DocumentSpec::set_date(HTTPDate const &date);

613 8 has_date 0 4 816 22 DocumentSpec::has_date 0 1 217 84
/**
 * Returns true if a last-modified date is associated with the DocumentSpec.
 */
47
inline bool DocumentSpec::has_date(void) const;

614 8 get_date 0 4 816 22 DocumentSpec::get_date 0 1 218 153
/**
 * Returns the last-modified date associated with the DocumentSpec, if there
 * is one.  It is an error to call this if has_date() returns false.
 */
58
inline HTTPDate const &DocumentSpec::get_date(void) const;

615 10 clear_date 0 4 816 24 DocumentSpec::clear_date 0 1 219 95
/**
 * Removes the last-modified date associated with the DocumentSpec, if there
 * is one.
 */
43
inline void DocumentSpec::clear_date(void);

616 16 set_request_mode 0 4 816 30 DocumentSpec::set_request_mode 0 1 220 1335
/**
 * Sets the request mode of this DocumentSpec.  This is only relevant when
 * using the DocumentSpec to generate a request (for instance, in
 * HTTPChannel).  This specifies whether the document request will ask the
 * server for a newer version than the indicated version, or the exact
 * version, neither, or either.
 *
 * The possible values are:
 *
 * RM_any: ignore date and tag (if specified), and retrieve any document that
 * matches the URL.  For a subrange request, if the document matches the
 * version indicated exactly, retrieve the subrange only; otherwise, retrieve
 * the entire document.
 *
 * RM_equal: request only the precise version of the document that matches the
 * particular date and/or tag exactly, if specified; fail if this version is
 * not available.
 *
 * RM_newer: request any document that is newer than the version indicated by
 * the particular date and/or tag; fail if only that version (or older
 * versions) are available.
 *
 * RM_newer_or_equal: request any document that matches the version indicated
 * by the particular date and/or tag, or is a newer version; fail if only
 * older versions are available.
 *
 * In any of the above, you may specify either or both of the last-modified
 * date and the identity tag, whichever is known to the client.
 *
 * The default mode is RM_any.
 */
83
inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode);

617 16 get_request_mode 0 4 816 30 DocumentSpec::get_request_mode 0 1 221 82
/**
 * Returns the request mode of this DocumentSpec.  See set_request_mode().
 */
76
inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const;

618 17 set_cache_control 0 4 816 31 DocumentSpec::set_cache_control 0 1 222 642
/**
 * Specifies what kind of cached value is acceptable for this document.
 * Warning: some HTTP proxies may not respect this setting and may return a
 * cached result anyway.
 *
 * CC_allow_cache: the normal HTTP behavior; the server may return a cached
 * value if it believes it is valid.
 *
 * CC_revalidate: a proxy is forced to contact the origin server and verify
 * that is cached value is in fact still valid before it returns it.
 *
 * CC_no_cache: a proxy must not return its cached value at all, but is forced
 * to go all the way back to the origin server for the official document.
 *
 * The default mode is CC_allow_cache.
 */
86
inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control);

619 17 get_cache_control 0 4 816 31 DocumentSpec::get_cache_control 0 1 223 83
/**
 * Returns the request mode of this DocumentSpec.  See set_cache_control().
 */
78
inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const;

620 5 input 0 4 816 19 DocumentSpec::input 0 1 224 152
/**
 * Can be used to read in the DocumentSpec from a stream generated either by
 * output() or write().  Returns true on success, false on failure.
 */
43
bool DocumentSpec::input(std::istream &in);

621 6 output 0 4 816 20 DocumentSpec::output 0 1 225 10
/**
 *
 */
51
void DocumentSpec::output(std::ostream &out) const;

622 5 write 0 4 816 19 DocumentSpec::write 0 1 226 10
/**
 *
 */
72
void DocumentSpec::write(std::ostream &out, int indent_level = 0) const;

623 13 ~DocumentSpec 0 4 816 27 DocumentSpec::~DocumentSpec 0 0 0
34
DocumentSpec::~DocumentSpec(void);

624 10 get_client 0 4 822 23 HTTPChannel::get_client 0 1 228 64
/**
 * Returns the HTTPClient object that owns this channel.
 */
55
inline HTTPClient *HTTPChannel::get_client(void) const;

625 8 is_valid 0 4 822 21 HTTPChannel::is_valid 0 1 229 126
/**
 * Returns true if the last-requested document was successfully retrieved and
 * is ready to be read, false otherwise.
 */
46
inline bool HTTPChannel::is_valid(void) const;

626 19 is_connection_ready 0 4 822 32 HTTPChannel::is_connection_ready 0 1 230 158
/**
 * Returns true if a connection has been established to the named server in a
 * previous call to connect_to() or begin_connect_to(), false otherwise.
 */
57
inline bool HTTPChannel::is_connection_ready(void) const;

627 7 get_url 0 4 822 20 HTTPChannel::get_url 0 1 231 287
/**
 * Returns the URL that was used to retrieve the most recent document:
 * whatever URL was last passed to get_document() or get_header().  If a
 * redirect has transparently occurred, this will return the new, redirected
 * URL (the actual URL at which the document was located).
 */
55
inline URLSpec const &HTTPChannel::get_url(void) const;

628 17 get_document_spec 0 4 822 30 HTTPChannel::get_document_spec 0 1 232 380
/**
 * Returns the DocumentSpec associated with the most recent document.  This
 * includes its actual URL (following redirects) along with the identity tag
 * and last-modified date, if supplied by the server.
 *
 * This structure may be saved and used to retrieve the same version of the
 * document later, or to conditionally retrieve a newer version if it is
 * available.
 */
70
inline DocumentSpec const &HTTPChannel::get_document_spec(void) const;

629 16 get_http_version 0 4 822 29 HTTPChannel::get_http_version 0 1 233 137
/**
 * Returns the HTTP version number returned by the server, as one of the
 * HTTPClient enumerated types, e.g.  HTTPClient::HV_11.
 */
71
inline HTTPEnum::HTTPVersion HTTPChannel::get_http_version(void) const;

630 23 get_http_version_string 0 4 822 36 HTTPChannel::get_http_version_string 0 1 234 110
/**
 * Returns the HTTP version number returned by the server, formatted as a
 * string, e.g.  "HTTP/1.1".
 */
75
inline std::string const &HTTPChannel::get_http_version_string(void) const;

631 15 get_status_code 0 4 822 28 HTTPChannel::get_status_code 0 1 235 501
/**
 * Returns the HTML return code from the document retrieval request.  This
 * will be in the 200 range if the document is successfully retrieved, or some
 * other value in the case of an error.
 *
 * Some proxy errors during an https-over-proxy request would return the same
 * status code as a different error that occurred on the host server.  To
 * differentiate these cases, status codes that are returned by the proxy
 * during the CONNECT phase (except code 407) are incremented by 1000.
 */
52
inline int HTTPChannel::get_status_code(void) const;

632 17 get_status_string 0 4 822 30 HTTPChannel::get_status_string 0 1 236 133
/**
 * Returns the string as returned by the server describing the status code for
 * humans.  This may or may not be meaningful.
 */
55
std::string HTTPChannel::get_status_string(void) const;

633 13 get_www_realm 0 4 822 26 HTTPChannel::get_www_realm 0 1 237 363
/**
 * If the document failed to connect because of a 401 (Authorization
 * required), this method will return the "realm" returned by the server in
 * which the requested document must be authenticated.  This string may be
 * presented to the user to request an associated username and password (which
 * then should be stored in HTTPClient::set_username()).
 */
65
inline std::string const &HTTPChannel::get_www_realm(void) const;

634 15 get_proxy_realm 0 4 822 28 HTTPChannel::get_proxy_realm 0 1 238 311
/**
 * If the document failed to connect because of a 407 (Proxy authorization
 * required), this method will return the "realm" returned by the proxy.  This
 * string may be presented to the user to request an associated username and
 * password (which then should be stored in HTTPClient::set_username()).
 */
67
inline std::string const &HTTPChannel::get_proxy_realm(void) const;

635 12 get_redirect 0 4 822 25 HTTPChannel::get_redirect 0 1 239 366
/**
 * If the document failed with a redirect code (300 series), this will
 * generally contain the new URL the server wants us to try.  In many cases,
 * the client will automatically follow redirects; if these are successful the
 * client will return a successful code and get_redirect() will return empty,
 * but get_url() will return the new, redirected URL.
 */
60
inline URLSpec const &HTTPChannel::get_redirect(void) const;

636 16 get_header_value 0 4 822 29 HTTPChannel::get_header_value 0 1 240 160
/**
 * Returns the HTML header value associated with the indicated key, or empty
 * string if the key was not defined in the message returned by the server.
 */
72
std::string HTTPChannel::get_header_value(std::string const &key) const;

637 22 get_num_redirect_steps 0 4 822 35 HTTPChannel::get_num_redirect_steps 0 1 241 212
/**
 * If the document automatically followed one or more redirects, this will
 * return the number of redirects that were automatically followed.  Use
 * get_redirect_step() to retrieve each URL in sequence.
 */
59
inline int HTTPChannel::get_num_redirect_steps(void) const;

638 17 get_redirect_step 0 4 822 30 HTTPChannel::get_redirect_step 0 1 242 182
/**
 * Use in conjunction with get_num_redirect_steps() to extract the chain of
 * URL's that the channel was automatically redirected through to arrive at
 * the final document.
 */
66
inline URLSpec const &HTTPChannel::get_redirect_step(int n) const;

639 25 set_persistent_connection 0 4 822 38 HTTPChannel::set_persistent_connection 0 1 243 532
/**
 * Indicates whether the HTTPChannel should try to keep the connection to the
 * server open and reuse that connection for multiple documents, or whether it
 * should close the connection and open a new one for each request.  Set this
 * true to keep the connections around when possible, false to recycle them.
 *
 * It makes most sense to set this false when the HTTPChannel will be used
 * only once to retrieve a single document, true when you will be using the
 * same HTTPChannel object to retrieve multiple documents.
 */
79
inline void HTTPChannel::set_persistent_connection(bool persistent_connection);

640 25 get_persistent_connection 0 4 822 38 HTTPChannel::get_persistent_connection 0 1 244 267
/**
 * Returns whether the HTTPChannel should try to keep the connection to the
 * server open and reuse that connection for multiple documents, or whether it
 * should close the connection and open a new one for each request.  See
 * set_persistent_connection().
 */
63
inline bool HTTPChannel::get_persistent_connection(void) const;

641 21 will_close_connection 0 4 822 34 HTTPChannel::will_close_connection 0 1 245 217
/**
 * Returns true if the server has indicated it will close the connection after
 * this document has been read, or false if it will remain open (and future
 * documents may be requested on the same connection).
 */
52
bool HTTPChannel::will_close_connection(void) const;

642 15 set_allow_proxy 0 4 822 28 HTTPChannel::set_allow_proxy 0 1 246 325
/**
 * If this is true (the normal case), the HTTPClient will be consulted for
 * information about the proxy to be used for each connection via this
 * HTTPChannel.  If this has been set to false by the user, then all
 * connections will be made directly, regardless of the proxy settings
 * indicated on the HTTPClient.
 */
59
inline void HTTPChannel::set_allow_proxy(bool allow_proxy);

643 15 get_allow_proxy 0 4 822 28 HTTPChannel::get_allow_proxy 0 1 247 325
/**
 * If this is true (the normal case), the HTTPClient will be consulted for
 * information about the proxy to be used for each connection via this
 * HTTPChannel.  If this has been set to false by the user, then all
 * connections will be made directly, regardless of the proxy settings
 * indicated on the HTTPClient.
 */
53
inline bool HTTPChannel::get_allow_proxy(void) const;

644 16 set_proxy_tunnel 0 4 822 29 HTTPChannel::set_proxy_tunnel 0 1 248 795
/**
 * Normally, a proxy is itself asked for ordinary URL's, and the proxy decides
 * whether to hand the client a cached version of the document or to contact
 * the server for a fresh version.  The proxy may also modify the headers and
 * transfer encoding on the way.
 *
 * If this is set to true, then instead of asking for URL's from the proxy, we
 * will ask the proxy to open a connection to the server (for instance, on
 * port 80); if the proxy honors this request, then we contact the server
 * directly through this connection to retrieve the document.  If the proxy
 * does not honor the connect request, then the retrieve operation fails.
 *
 * SSL connections (e.g.  https), and connections through a Socks proxy, are
 * always tunneled, regardless of the setting of this flag.
 */
61
inline void HTTPChannel::set_proxy_tunnel(bool proxy_tunnel);

645 16 get_proxy_tunnel 0 4 822 29 HTTPChannel::get_proxy_tunnel 0 1 249 172
/**
 * Returns true if connections always tunnel through a proxy, or false (the
 * normal case) if we allow the proxy to serve up documents.  See
 * set_proxy_tunnel().
 */
54
inline bool HTTPChannel::get_proxy_tunnel(void) const;

646 19 set_connect_timeout 0 4 822 32 HTTPChannel::set_connect_timeout 0 1 250 322
/**
 * Sets the maximum length of time, in seconds, that the channel will wait
 * before giving up on establishing a TCP connection.
 *
 * At present, this is used only for the nonblocking interfaces (e.g.
 * begin_get_document(), begin_connect_to()), but it is used whether
 * set_blocking_connect() is true or false.
 */
69
inline void HTTPChannel::set_connect_timeout(double timeout_seconds);

647 19 get_connect_timeout 0 4 822 32 HTTPChannel::get_connect_timeout 0 1 251 130
/**
 * Returns the length of time, in seconds, to wait for a new nonblocking
 * socket to connect.  See set_connect_timeout().
 */
59
inline double HTTPChannel::get_connect_timeout(void) const;

648 20 set_blocking_connect 0 4 822 33 HTTPChannel::set_blocking_connect 0 1 252 641
/**
 * If this flag is true, a socket connect will block even for nonblocking I/O
 * calls like begin_get_document(), begin_connect_to(), etc.  If false, a
 * socket connect will not block for nonblocking I/O calls, but will block for
 * blocking I/O calls (get_document(), connect_to(), etc.).
 *
 * Setting this true is useful when you want to use non-blocking I/O once you
 * have established the connection, but you don't want to bother with polling
 * for the initial connection.  It's also useful when you don't particularly
 * care about non-blocking I/O, but you need to respect timeouts like
 * connect_timeout and http_timeout.
 */
69
inline void HTTPChannel::set_blocking_connect(bool blocking_connect);

649 20 get_blocking_connect 0 4 822 33 HTTPChannel::get_blocking_connect 0 1 253 298
/**
 * If this flag is true, a socket connect will block even for nonblocking I/O
 * calls like begin_get_document(), begin_connect_to(), etc.  If false, a
 * socket connect will not block for nonblocking I/O calls, but will block for
 * blocking I/O calls (get_document(), connect_to(), etc.).
 */
58
inline bool HTTPChannel::get_blocking_connect(void) const;

650 16 set_http_timeout 0 4 822 29 HTTPChannel::set_http_timeout 0 1 254 485
/**
 * Sets the maximum length of time, in seconds, that the channel will wait for
 * the HTTP server to finish sending its response to our request.
 *
 * The timer starts counting after the TCP connection has been established
 * (see set_connect_timeout(), above) and the request has been sent.
 *
 * At present, this is used only for the nonblocking interfaces (e.g.
 * begin_get_document(), begin_connect_to()), but it is used whether
 * set_blocking_connect() is true or false.
 */
66
inline void HTTPChannel::set_http_timeout(double timeout_seconds);

651 16 get_http_timeout 0 4 822 29 HTTPChannel::get_http_timeout 0 1 255 133
/**
 * Returns the length of time, in seconds, to wait for the HTTP server to
 * respond to our request.  See set_http_timeout().
 */
56
inline double HTTPChannel::get_http_timeout(void) const;

652 18 set_skip_body_size 0 4 822 31 HTTPChannel::set_skip_body_size 0 1 256 632
/**
 * Specifies the maximum number of bytes in a received (but unwanted) body
 * that will be skipped past, in order to reset to a new request.
 *
 * That is, if this HTTPChannel requests a file via get_document(), but does
 * not call download_to_ram(), download_to_file(), or open_read_body(), and
 * instead immediately requests a new file, then the HTTPChannel has a choice
 * whether to skip past the unwanted document, or to close the connection and
 * open a new one.  If the number of bytes to skip is more than this
 * threshold, the connection will be closed; otherwise, the data will simply
 * be read and discarded.
 */
72
inline void HTTPChannel::set_skip_body_size(std::size_t skip_body_size);

653 18 get_skip_body_size 0 4 822 31 HTTPChannel::get_skip_body_size 0 1 257 176
/**
 * Returns the maximum number of bytes in a received (but unwanted) body that
 * will be skipped past, in order to reset to a new request.  See
 * set_skip_body_size().
 */
63
inline std::size_t HTTPChannel::get_skip_body_size(void) const;

654 16 set_idle_timeout 0 4 822 29 HTTPChannel::set_idle_timeout 0 1 258 387
/**
 * Specifies the amount of time, in seconds, in which a previously-established
 * connection is allowed to remain open and unused.  If a previous connection
 * has remained unused for at least this number of seconds, it will be closed
 * and a new connection will be opened; otherwise, the same connection will be
 * reused for the next request (for this particular HTTPChannel).
 */
63
inline void HTTPChannel::set_idle_timeout(double idle_timeout);

655 16 get_idle_timeout 0 4 822 29 HTTPChannel::get_idle_timeout 0 1 259 162
/**
 * Returns the amount of time, in seconds, in which an previously-established
 * connection is allowed to remain open and unused.  See set_idle_timeout().
 */
56
inline double HTTPChannel::get_idle_timeout(void) const;

656 21 set_download_throttle 0 4 822 34 HTTPChannel::set_download_throttle 0 1 260 686
/**
 * Specifies whether nonblocking downloads (via download_to_file() or
 * download_to_ram()) will be limited so as not to use all available
 * bandwidth.
 *
 * If this is true, when a download has been started on this channel it will
 * be invoked no more frequently than get_max_updates_per_second(), and the
 * total bandwidth used by the download will be no more than
 * get_max_bytes_per_second().  If this is false, downloads will proceed as
 * fast as the server can send the data.
 *
 * This only has effect on the nonblocking I/O methods like
 * begin_get_document(), etc.  The blocking methods like get_document() always
 * use as much CPU and bandwidth as they can get.
 */
71
inline void HTTPChannel::set_download_throttle(bool download_throttle);

657 21 get_download_throttle 0 4 822 34 HTTPChannel::get_download_throttle 0 1 261 112
/**
 * Returns whether the nonblocking downloads will be bandwidth-limited.  See
 * set_download_throttle().
 */
59
inline bool HTTPChannel::get_download_throttle(void) const;

658 24 set_max_bytes_per_second 0 4 822 37 HTTPChannel::set_max_bytes_per_second 0 1 262 178
/**
 * When bandwidth throttling is in effect (see set_download_throttle()), this
 * specifies the maximum number of bytes per second that may be consumed by
 * this channel.
 */
79
inline void HTTPChannel::set_max_bytes_per_second(double max_bytes_per_second);

659 24 get_max_bytes_per_second 0 4 822 37 HTTPChannel::get_max_bytes_per_second 0 1 263 135
/**
 * Returns the maximum number of bytes per second that may be consumed by this
 * channel when get_download_throttle() is true.
 */
64
inline double HTTPChannel::get_max_bytes_per_second(void) const;

660 26 set_max_updates_per_second 0 4 822 39 HTTPChannel::set_max_updates_per_second 0 1 264 194
/**
 * When bandwidth throttling is in effect (see set_download_throttle()), this
 * specifies the maximum number of times per second that run() will attempt to
 * do any downloading at all.
 */
83
inline void HTTPChannel::set_max_updates_per_second(double max_updates_per_second);

661 26 get_max_updates_per_second 0 4 822 39 HTTPChannel::get_max_updates_per_second 0 1 265 134
/**
 * Returns the maximum number of times per second that run() will do anything
 * at all, when get_download_throttle() is true.
 */
66
inline double HTTPChannel::get_max_updates_per_second(void) const;

662 16 set_content_type 0 4 822 29 HTTPChannel::set_content_type 0 1 266 127
/**
 * Specifies the Content-Type header, useful for applications that require
 * different types of content, such as JSON.
 */
68
inline void HTTPChannel::set_content_type(std::string content_type);

663 16 get_content_type 0 4 822 29 HTTPChannel::get_content_type 0 1 267 56
/**
 * Returns the value of the Content-Type header.
 */
61
inline std::string HTTPChannel::get_content_type(void) const;

664 22 set_expected_file_size 0 4 822 35 HTTPChannel::set_expected_file_size 0 1 268 320
/**
 * This may be called immediately after a call to get_document() or some
 * related function to specify the expected size of the document we are
 * retrieving, if we happen to know.  This is used as the return value to
 * get_file_size() only in the case that the server does not tell us the
 * actual file size.
 */
71
inline void HTTPChannel::set_expected_file_size(std::size_t file_size);

665 13 get_file_size 0 4 822 26 HTTPChannel::get_file_size 0 1 269 506
/**
 * Returns the size of the file, if it is known.  Returns the value set by
 * set_expected_file_size() if the file size is not known, or 0 if this value
 * was not set.
 *
 * If the file is dynamically generated, the size may not be available until a
 * read has started (e.g.  open_read_body() has been called); and even then it
 * may increase as more of the file is read due to the nature of HTTP/1.1
 * requests which can change their minds midstream about how much data they're
 * sending you.
 */
55
std::streamsize HTTPChannel::get_file_size(void) const;

666 18 is_file_size_known 0 4 822 31 HTTPChannel::is_file_size_known 0 1 270 327
/**
 * Returns true if the size of the file we are currently retrieving was told
 * us by the server and thus is reliably known, or false if the size reported
 * by get_file_size() represents an educated guess (possibly as set by
 * set_expected_file_size(), or as inferred from a chunked transfer encoding
 * in progress).
 */
56
inline bool HTTPChannel::is_file_size_known(void) const;

667 24 get_first_byte_requested 0 4 822 37 HTTPChannel::get_first_byte_requested 0 1 271 289
/**
 * Returns the first byte of the file requested by the request.  This will
 * normally be 0 to indicate that the file is being requested from the
 * beginning, but if the file was requested via a get_subdocument() call, this
 * will contain the first_byte parameter from that call.
 */
69
inline std::size_t HTTPChannel::get_first_byte_requested(void) const;

668 23 get_last_byte_requested 0 4 822 36 HTTPChannel::get_last_byte_requested 0 1 272 285
/**
 * Returns the last byte of the file requested by the request.  This will
 * normally be 0 to indicate that the file is being requested to its last
 * byte, but if the file was requested via a get_subdocument() call, this will
 * contain the last_byte parameter from that call.
 */
68
inline std::size_t HTTPChannel::get_last_byte_requested(void) const;

669 24 get_first_byte_delivered 0 4 822 37 HTTPChannel::get_first_byte_delivered 0 1 273 367
/**
 * Returns the first byte of the file (that will be) delivered by the server
 * in response to the current request.  Normally, this is the same as
 * get_first_byte_requested(), but some servers will ignore a subdocument
 * request and always return the whole file, in which case this value will be
 * 0, regardless of what was requested to get_subdocument().
 */
69
inline std::size_t HTTPChannel::get_first_byte_delivered(void) const;

670 23 get_last_byte_delivered 0 4 822 36 HTTPChannel::get_last_byte_delivered 0 1 274 365
/**
 * Returns the last byte of the file (that will be) delivered by the server in
 * response to the current request.  Normally, this is the same as
 * get_last_byte_requested(), but some servers will ignore a subdocument
 * request and always return the whole file, in which case this value will be
 * 0, regardless of what was requested to get_subdocument().
 */
68
inline std::size_t HTTPChannel::get_last_byte_delivered(void) const;

671 13 write_headers 0 4 822 26 HTTPChannel::write_headers 0 1 275 97
/**
 * Outputs a list of all headers defined by the server to the indicated output
 * stream.
 */
57
void HTTPChannel::write_headers(std::ostream &out) const;

672 5 reset 0 4 822 18 HTTPChannel::reset 0 1 276 538
/**
 * Stops whatever file transaction is currently in progress, closes the
 * connection, and resets to begin anew.  You shouldn't ever need to call
 * this, since the channel should be able to reset itself cleanly between
 * requests, but it is provided in case you are an especially nervous type.
 *
 * Don't call this after every request unless you set
 * set_persistent_connection() to false, since calling reset() rudely closes
 * the connection regardless of whether we have told the server we intend to
 * keep it open or not.
 */
37
inline void HTTPChannel::reset(void);

673 15 preserve_status 0 4 822 28 HTTPChannel::preserve_status 0 1 277 487
/**
 * Preserves the previous status code (presumably a failure) from the previous
 * connection attempt.  If the subsequent connection attempt also fails, the
 * returned status code will be the better of the previous code and the
 * current code.
 *
 * This can be called to daisy-chain subsequent attempts to download the same
 * document from different servers.  After all servers have been attempted,
 * the final status code will reflect the attempt that most nearly succeeded.
 */
47
inline void HTTPChannel::preserve_status(void);

674 19 clear_extra_headers 0 4 822 32 HTTPChannel::clear_extra_headers 0 1 278 99
/**
 * Resets the extra headers that were previously added via calls to
 * send_extra_header().
 */
51
inline void HTTPChannel::clear_extra_headers(void);

675 17 send_extra_header 0 4 822 30 HTTPChannel::send_extra_header 0 1 279 352
/**
 * Specifies an additional key: value pair that is added into the header sent
 * to the server with the next request.  This is passed along with no
 * interpretation by the HTTPChannel code.  You may call this repeatedly to
 * append multiple headers.
 *
 * This is persistent for one request only; it must be set again for each new
 * request.
 */
93
inline void HTTPChannel::send_extra_header(std::string const &key, std::string const &value);

676 12 get_document 0 4 822 25 HTTPChannel::get_document 0 1 280 111
/**
 * Opens the named document for reading, if available.  Returns true if
 * successful, false otherwise.
 */
63
inline bool HTTPChannel::get_document(DocumentSpec const &url);

677 15 get_subdocument 0 4 822 28 HTTPChannel::get_subdocument 0 1 281 313
/**
 * Retrieves only the specified byte range of the indicated document.  If
 * last_byte is 0, it stands for the last byte of the document.  When a
 * subdocument is requested, get_file_size() and get_bytes_downloaded() will
 * report the number of bytes of the subdocument, not of the complete
 * document.
 */
113
inline bool HTTPChannel::get_subdocument(DocumentSpec const &url, std::size_t first_byte, std::size_t last_byte);

678 10 get_header 0 4 822 23 HTTPChannel::get_header 0 1 282 252
/**
 * Like get_document(), except only the header associated with the document is
 * retrieved.  This may be used to test for existence of the document; it
 * might also return the size of the document (if the server gives us this
 * information).
 */
61
inline bool HTTPChannel::get_header(DocumentSpec const &url);

679 9 post_form 0 4 822 22 HTTPChannel::post_form 0 1 283 74
/**
 * Posts form data to a particular URL and retrieves the response.
 */
85
inline bool HTTPChannel::post_form(DocumentSpec const &url, std::string const &body);

680 12 put_document 0 4 822 25 HTTPChannel::put_document 0 1 284 111
/**
 * Uploads the indicated body to the server to replace the indicated URL, if
 * the server allows this.
 */
88
inline bool HTTPChannel::put_document(DocumentSpec const &url, std::string const &body);

681 15 delete_document 0 4 822 28 HTTPChannel::delete_document 0 1 285 59
/**
 * Requests the server to remove the indicated URL.
 */
66
inline bool HTTPChannel::delete_document(DocumentSpec const &url);

682 9 get_trace 0 4 822 22 HTTPChannel::get_trace 0 1 286 159
/**
 * Sends a TRACE message to the server, which should return back the same
 * message as the server received it, allowing inspection of proxy hops, etc.
 */
60
inline bool HTTPChannel::get_trace(DocumentSpec const &url);

683 10 connect_to 0 4 822 23 HTTPChannel::connect_to 0 1 287 319
/**
 * Establish a direct connection to the server and port indicated by the URL,
 * but do not issue any HTTP requests.  If successful, the connection may then
 * be taken to use for whatever purposes you like by calling get_connection().
 *
 * This establishes a blocking I/O socket.  Also see begin_connect_to().
 */
61
inline bool HTTPChannel::connect_to(DocumentSpec const &url);

684 11 get_options 0 4 822 24 HTTPChannel::get_options 0 1 288 136
/**
 * Sends an OPTIONS message to the server, which should query the available
 * options, possibly in relation to a specified URL.
 */
62
inline bool HTTPChannel::get_options(DocumentSpec const &url);

685 18 begin_get_document 0 4 822 31 HTTPChannel::begin_get_document 0 1 289 445
/**
 * Begins a non-blocking request to retrieve a given document.  This method
 * will return immediately, even before a connection to the server has
 * necessarily been established; you must then call run() from time to time
 * until the return value of run() is false.  Then you may check is_valid()
 * and get_status_code() to determine the status of your request.
 *
 * If a previous request had been pending, that request is discarded.
 */
69
inline void HTTPChannel::begin_get_document(DocumentSpec const &url);

686 21 begin_get_subdocument 0 4 822 34 HTTPChannel::begin_get_subdocument 0 1 290 345
/**
 * Begins a non-blocking request to retrieve only the specified byte range of
 * the indicated document.  If last_byte is 0, it stands for the last byte of
 * the document.  When a subdocument is requested, get_file_size() and
 * get_bytes_downloaded() will report the number of bytes of the subdocument,
 * not of the complete document.
 */
119
inline void HTTPChannel::begin_get_subdocument(DocumentSpec const &url, std::size_t first_byte, std::size_t last_byte);

687 16 begin_get_header 0 4 822 29 HTTPChannel::begin_get_header 0 1 291 115
/**
 * Begins a non-blocking request to retrieve a given header.  See
 * begin_get_document() and get_header().
 */
67
inline void HTTPChannel::begin_get_header(DocumentSpec const &url);

688 15 begin_post_form 0 4 822 28 HTTPChannel::begin_post_form 0 1 292 431
/**
 * Posts form data to a particular URL and retrieves the response, all using
 * non-blocking I/O.  See begin_get_document() and post_form().
 *
 * It is important to note that you *must* call run() repeatedly after calling
 * this method until run() returns false, and you may not call any other
 * document posting or retrieving methods using the HTTPChannel object in the
 * interim, or your form data may not get posted.
 */
91
inline void HTTPChannel::begin_post_form(DocumentSpec const &url, std::string const &body);

689 3 run 0 4 822 16 HTTPChannel::run 0 1 293 425
/**
 * This must be called from time to time when non-blocking I/O is in use.  It
 * checks for data coming in on the socket and writes data out to the socket
 * when possible, and does whatever processing is required towards completing
 * the current task.
 *
 * The return value is true if the task is still pending (and run() will need
 * to be called again in the future), or false if the current task is
 * complete.
 */
28
bool HTTPChannel::run(void);

690 16 begin_connect_to 0 4 822 29 HTTPChannel::begin_connect_to 0 1 294 536
/**
 * Begins a non-blocking request to establish a direct connection to the
 * server and port indicated by the URL.  No HTTP requests will be issued
 * beyond what is necessary to establish the connection.  When run() has
 * finished, you may call is_connection_ready() to determine if the connection
 * was successfully established.
 *
 * If successful, the connection may then be taken to use for whatever
 * purposes you like by calling get_connection().
 *
 * This establishes a nonblocking I/O socket.  Also see connect_to().
 */
67
inline void HTTPChannel::begin_connect_to(DocumentSpec const &url);

691 14 open_read_body 0 4 822 27 HTTPChannel::open_read_body 0 1 295 569
/**
 * Returns a newly-allocated istream suitable for reading the body of the
 * document.  This may only be called immediately after a call to
 * get_document() or post_form(), or after a call to run() has returned false.
 *
 * Note that, in nonblocking mode, the returned stream may report an early
 * EOF, even before the actual end of file.  When this happens, you should
 * call stream->is_closed() to determine whether you should attempt to read
 * some more later.
 *
 * The user is responsible for passing the returned istream to
 * close_read_body() later.
 */
49
ISocketStream *HTTPChannel::open_read_body(void);

692 15 close_read_body 0 4 822 28 HTTPChannel::close_read_body 0 1 296 243
/**
 * Closes a file opened by a previous call to open_read_body().  This really
 * just deletes the istream pointer, but it is recommended to use this
 * interface instead of deleting it explicitly, to help work around compiler
 * issues.
 */
62
void HTTPChannel::close_read_body(std::istream *stream) const;

693 16 download_to_file 0 4 822 29 HTTPChannel::download_to_file 0 1 297 1345
/**
 * Specifies the name of a file to download the resulting document to.  This
 * should be called immediately after get_document() or begin_get_document()
 * or related functions.
 *
 * In the case of the blocking I/O methods like get_document(), this function
 * will download the entire document to the file and return true if it was
 * successfully downloaded, false otherwise.
 *
 * In the case of non-blocking I/O methods like begin_get_document(), this
 * function simply indicates an intention to download to the indicated file.
 * It returns true if the file can be opened for writing, false otherwise, but
 * the contents will not be completely downloaded until run() has returned
 * false.  At this time, it is possible that a communications error will have
 * left a partial file, so is_download_complete() may be called to test this.
 *
 * If subdocument_resumes is true and the document in question was previously
 * requested as a subdocument (i.e.  get_subdocument() with a first_byte value
 * greater than zero), this will automatically seek to the appropriate byte
 * within the file for writing the output.  In this case, the file must
 * already exist and must have at least first_byte bytes in it.  If
 * subdocument_resumes is false, a subdocument will always be downloaded
 * beginning at the first byte of the file.
 */
94
bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes = true);

694 15 download_to_ram 0 4 822 28 HTTPChannel::download_to_ram 0 1 298 1223
/**
 * Specifies a Ramfile object to download the resulting document to.  This
 * should be called immediately after get_document() or begin_get_document()
 * or related functions.
 *
 * In the case of the blocking I/O methods like get_document(), this function
 * will download the entire document to the Ramfile and return true if it was
 * successfully downloaded, false otherwise.
 *
 * In the case of non-blocking I/O methods like begin_get_document(), this
 * function simply indicates an intention to download to the indicated
 * Ramfile.  It returns true if the file can be opened for writing, false
 * otherwise, but the contents will not be completely downloaded until run()
 * has returned false.  At this time, it is possible that a communications
 * error will have left a partial file, so is_download_complete() may be
 * called to test this.
 *
 * If subdocument_resumes is true and the document in question was previously
 * requested as a subdocument (i.e.  get_subdocument() with a first_byte value
 * greater than zero), this will automatically seek to the appropriate byte
 * within the Ramfile for writing the output.  In this case, the Ramfile must
 * already have at least first_byte bytes in it.
 */
85
bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes = true);

695 18 download_to_stream 0 4 822 31 HTTPChannel::download_to_stream 0 1 299 1348
/**
 * Specifies the name of an ostream to download the resulting document to.
 * This should be called immediately after get_document() or
 * begin_get_document() or related functions.
 *
 * In the case of the blocking I/O methods like get_document(), this function
 * will download the entire document to the file and return true if it was
 * successfully downloaded, false otherwise.
 *
 * In the case of non-blocking I/O methods like begin_get_document(), this
 * function simply indicates an intention to download to the indicated file.
 * It returns true if the file can be opened for writing, false otherwise, but
 * the contents will not be completely downloaded until run() has returned
 * false.  At this time, it is possible that a communications error will have
 * left a partial file, so is_download_complete() may be called to test this.
 *
 * If subdocument_resumes is true and the document in question was previously
 * requested as a subdocument (i.e.  get_subdocument() with a first_byte value
 * greater than zero), this will automatically seek to the appropriate byte
 * within the file for writing the output.  In this case, the file must
 * already exist and must have at least first_byte bytes in it.  If
 * subdocument_resumes is false, a subdocument will always be downloaded
 * beginning at the first byte of the file.
 */
90
bool HTTPChannel::download_to_stream(std::ostream *strm, bool subdocument_resumes = true);

696 14 get_connection 0 4 822 27 HTTPChannel::get_connection 0 1 300 351
/**
 * Returns the connection that was established via a previous call to
 * connect_to() or begin_connect_to(), or NULL if the connection attempt
 * failed or if those methods have not recently been called.
 *
 * This stream has been allocated from the free store.  It is the user's
 * responsibility to delete this pointer when finished with it.
 */
48
SocketStream *HTTPChannel::get_connection(void);

697 20 get_bytes_downloaded 0 4 822 33 HTTPChannel::get_bytes_downloaded 0 1 301 331
/**
 * Returns the number of bytes downloaded during the last (or current)
 * download_to_file() or download_to_ram operation().  This can be used in
 * conjunction with get_file_size() to report the percent complete (but be
 * careful, since get_file_size() may return 0 if the server has not told us
 * the size of the file).
 */
65
inline std::size_t HTTPChannel::get_bytes_downloaded(void) const;

698 19 get_bytes_requested 0 4 822 32 HTTPChannel::get_bytes_requested 0 1 302 658
/**
 * When download throttling is in effect (set_download_throttle() has been set
 * to true) and non-blocking I/O methods (like begin_get_document()) are used,
 * this returns the number of bytes "requested" from the server so far: that
 * is, the theoretical maximum value for get_bytes_downloaded(), if the server
 * has been keeping up with our demand.
 *
 * If this number is less than get_bytes_downloaded(), then the server has not
 * been supplying bytes fast enough to meet our own download throttle rate.
 *
 * When download throttling is not in effect, or when the blocking I/O methods
 * (like get_document(), etc.) are used, this returns 0.
 */
64
inline std::size_t HTTPChannel::get_bytes_requested(void) const;

699 20 is_download_complete 0 4 822 33 HTTPChannel::is_download_complete 0 1 303 600
/**
 * Returns true when a download_to() or download_to_ram() has executed and the
 * file has been fully downloaded.  If this still returns false after
 * processing has completed, there was an error in transmission.
 *
 * Note that simply testing is_download_complete() does not prove that the
 * requested document was successfully retrieved--you might have just
 * downloaded the "404 not found" stub (for instance) that a server would
 * provide in response to some error condition.  You should also check
 * is_valid() to prove that the file you expected has been successfully
 * retrieved.
 */
58
inline bool HTTPChannel::is_download_complete(void) const;

700 14 get_class_type 0 4 822 27 HTTPChannel::get_class_type 0 1 304 0
52
static TypeHandle HTTPChannel::get_class_type(void);

701 11 HTTPChannel 0 4 822 24 HTTPChannel::HTTPChannel 0 1 227 10
/**
 *
 */
63
inline HTTPChannel::HTTPChannel(HTTPChannel const &) = default;

702 12 Decompressor 0 4 825 26 Decompressor::Decompressor 0 2 305 306 10
/**
 *
 */
100
Decompressor::Decompressor(void);
inline Decompressor::Decompressor(Decompressor const &) = default;

703 13 ~Decompressor 0 4 825 27 Decompressor::~Decompressor 0 0 10
/**
 *
 */
34
Decompressor::~Decompressor(void);

704 8 initiate 0 4 825 22 Decompressor::initiate 0 2 307 308 365
/**
 * Begins a background decompression of the named file (whose filename must
 * end in ".pz") to a new file without the .pz extension.  The source file is
 * removed after successful completion.
 */

/**
 * Begins a background decompression from the named source file to the named
 * destination file.  The source file is removed after successful completion.
 */
140
int Decompressor::initiate(Filename const &source_file);
int Decompressor::initiate(Filename const &source_file, Filename const &dest_file);

705 3 run 0 4 825 17 Decompressor::run 0 1 309 227
/**
 * Called each frame to do the next bit of work in the background task.
 * Returns EU_ok if a chunk is completed but there is more to go, or
 * EU_success when we're all done.  Any other return value indicates an error.
 */
28
int Decompressor::run(void);

706 10 decompress 0 4 825 24 Decompressor::decompress 0 2 310 311 275
/**
 * Performs a foreground decompression of the named file; does not return
 * until the decompression is complete.
 */

/**
 * Does an in-memory decompression of the indicated Ramfile.  The decompressed
 * contents are written back into the same Ramfile on completion.
 */
121
bool Decompressor::decompress(Filename const &source_file);
bool Decompressor::decompress(Ramfile &source_and_dest_file);

707 12 get_progress 0 4 825 26 Decompressor::get_progress 0 1 312 78
/**
 * Returns the ratio through the decompression step in the background.
 */
51
PN_stdfloat Decompressor::get_progress(void) const;

708 10 DownloadDb 0 4 828 22 DownloadDb::DownloadDb 0 4 313 314 315 316 170
/**
 * Create a download db with these client and server dbs
 */

/**
 * Create a download db with these client and server dbs
 */

/**
 * Primarily used for testing.
 */
247
DownloadDb::DownloadDb(void);
explicit DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file);
explicit DownloadDb::DownloadDb(Filename &server_file, Filename &client_file);
inline DownloadDb::DownloadDb(DownloadDb const &) = default;

709 11 ~DownloadDb 0 4 828 23 DownloadDb::~DownloadDb 0 0 10
/**
 *
 */
30
DownloadDb::~DownloadDb(void);

710 6 output 0 4 828 18 DownloadDb::output 0 1 317 10
/**
 *
 */
49
void DownloadDb::output(std::ostream &out) const;

711 5 write 0 4 828 17 DownloadDb::write 0 1 318 10
/**
 *
 */
48
void DownloadDb::write(std::ostream &out) const;

712 17 write_version_map 0 4 828 29 DownloadDb::write_version_map 0 1 319 22
/**
 *
 */

/**
 *
 */
60
void DownloadDb::write_version_map(std::ostream &out) const;

713 15 write_client_db 0 4 828 27 DownloadDb::write_client_db 0 1 320 36
// Write a database file

/**
 *
 */
49
bool DownloadDb::write_client_db(Filename &file);

714 15 write_server_db 0 4 828 27 DownloadDb::write_server_db 0 1 321 10
/**
 *
 */
49
bool DownloadDb::write_server_db(Filename &file);

715 25 get_client_num_multifiles 0 4 828 37 DownloadDb::get_client_num_multifiles 0 1 322 10
/**
 *
 */
61
inline int DownloadDb::get_client_num_multifiles(void) const;

716 25 get_server_num_multifiles 0 4 828 37 DownloadDb::get_server_num_multifiles 0 1 323 10
/**
 *
 */
61
inline int DownloadDb::get_server_num_multifiles(void) const;

717 25 get_client_multifile_name 0 4 828 37 DownloadDb::get_client_multifile_name 0 1 324 10
/**
 *
 */
74
inline std::string DownloadDb::get_client_multifile_name(int index) const;

718 25 get_server_multifile_name 0 4 828 37 DownloadDb::get_server_multifile_name 0 1 325 10
/**
 *
 */
74
inline std::string DownloadDb::get_server_multifile_name(int index) const;

719 25 get_client_multifile_size 0 4 828 37 DownloadDb::get_client_multifile_size 0 1 326 10
/**
 *
 */
75
inline int DownloadDb::get_client_multifile_size(std::string mfname) const;

720 25 set_client_multifile_size 0 4 828 37 DownloadDb::set_client_multifile_size 0 1 327 10
/**
 *
 */
80
inline void DownloadDb::set_client_multifile_size(std::string mfname, int size);

721 31 set_client_multifile_delta_size 0 4 828 43 DownloadDb::set_client_multifile_delta_size 0 1 328 10
/**
 *
 */
85
inline int DownloadDb::set_client_multifile_delta_size(std::string mfname, int size);

722 25 get_server_multifile_size 0 4 828 37 DownloadDb::get_server_multifile_size 0 1 329 10
/**
 *
 */
75
inline int DownloadDb::get_server_multifile_size(std::string mfname) const;

723 25 set_server_multifile_size 0 4 828 37 DownloadDb::set_server_multifile_size 0 1 330 10
/**
 *
 */
80
inline void DownloadDb::set_server_multifile_size(std::string mfname, int size);

724 26 get_client_multifile_phase 0 4 828 38 DownloadDb::get_client_multifile_phase 0 1 331 10
/**
 *
 */
78
inline Phase DownloadDb::get_client_multifile_phase(std::string mfname) const;

725 26 get_server_multifile_phase 0 4 828 38 DownloadDb::get_server_multifile_phase 0 1 332 10
/**
 *
 */
78
inline Phase DownloadDb::get_server_multifile_phase(std::string mfname) const;

726 31 set_client_multifile_incomplete 0 4 828 43 DownloadDb::set_client_multifile_incomplete 0 1 333 10
/**
 *
 */
76
inline void DownloadDb::set_client_multifile_incomplete(std::string mfname);

727 29 set_client_multifile_complete 0 4 828 41 DownloadDb::set_client_multifile_complete 0 1 334 10
/**
 *
 */
74
inline void DownloadDb::set_client_multifile_complete(std::string mfname);

728 33 set_client_multifile_decompressed 0 4 828 45 DownloadDb::set_client_multifile_decompressed 0 1 335 10
/**
 *
 */
78
inline void DownloadDb::set_client_multifile_decompressed(std::string mfname);

729 30 set_client_multifile_extracted 0 4 828 42 DownloadDb::set_client_multifile_extracted 0 1 336 10
/**
 *
 */
75
inline void DownloadDb::set_client_multifile_extracted(std::string mfname);

730 20 get_server_num_files 0 4 828 32 DownloadDb::get_server_num_files 0 1 337 10
/**
 *
 */
70
inline int DownloadDb::get_server_num_files(std::string mfname) const;

731 20 get_server_file_name 0 4 828 32 DownloadDb::get_server_file_name 0 1 338 10
/**
 *
 */
89
inline std::string DownloadDb::get_server_file_name(std::string mfname, int index) const;

732 23 client_multifile_exists 0 4 828 35 DownloadDb::client_multifile_exists 0 1 339 40
// Queries from the Launcher

/**
 *
 */
67
bool DownloadDb::client_multifile_exists(std::string mfname) const;

733 25 client_multifile_complete 0 4 828 37 DownloadDb::client_multifile_complete 0 1 340 147
/**
 * A multifile is complete when it is completely downloaded.  Note: it may
 * already be decompressed or extracted and it is still complete
 */
69
bool DownloadDb::client_multifile_complete(std::string mfname) const;

734 29 client_multifile_decompressed 0 4 828 41 DownloadDb::client_multifile_decompressed 0 1 341 10
/**
 *
 */
73
bool DownloadDb::client_multifile_decompressed(std::string mfname) const;

735 26 client_multifile_extracted 0 4 828 38 DownloadDb::client_multifile_extracted 0 1 342 10
/**
 *
 */
70
bool DownloadDb::client_multifile_extracted(std::string mfname) const;

736 25 get_client_multifile_hash 0 4 828 37 DownloadDb::get_client_multifile_hash 0 1 343 122
// Ask what version (told with the hash) this multifile is

/**
 * Return the hash value of the file we are working on
 */
72
HashVal DownloadDb::get_client_multifile_hash(std::string mfname) const;

737 25 set_client_multifile_hash 0 4 828 37 DownloadDb::set_client_multifile_hash 0 1 344 55
/**
 * Set the hash value of file we are working on
 */
76
void DownloadDb::set_client_multifile_hash(std::string mfname, HashVal val);

738 25 get_server_multifile_hash 0 4 828 37 DownloadDb::get_server_multifile_hash 0 1 345 51
/**
 * Return the hash value of the server file
 */
72
HashVal DownloadDb::get_server_multifile_hash(std::string mfname) const;

739 25 set_server_multifile_hash 0 4 828 37 DownloadDb::set_server_multifile_hash 0 1 346 55
/**
 * Set the hash value of file we are working on
 */
76
void DownloadDb::set_server_multifile_hash(std::string mfname, HashVal val);

740 23 delete_client_multifile 0 4 828 35 DownloadDb::delete_client_multifile 0 1 347 39
// Operations on multifiles

/**
 *
 */
61
void DownloadDb::delete_client_multifile(std::string mfname);

741 20 add_client_multifile 0 4 828 32 DownloadDb::add_client_multifile 0 1 348 10
/**
 *
 */
65
void DownloadDb::add_client_multifile(std::string server_mfname);

742 23 expand_client_multifile 0 4 828 35 DownloadDb::expand_client_multifile 0 1 349 10
/**
 *
 */
61
void DownloadDb::expand_client_multifile(std::string mfname);

743 20 create_new_server_db 0 4 828 32 DownloadDb::create_new_server_db 0 1 350 131
// Server side operations to create multifile records

/**
 * Used on the server side makefiles to create a new clean server db
 */
44
void DownloadDb::create_new_server_db(void);

744 20 server_add_multifile 0 4 828 32 DownloadDb::server_add_multifile 0 1 351 10
/**
 *
 */
93
void DownloadDb::server_add_multifile(std::string mfname, Phase phase, int size, int status);

745 15 server_add_file 0 4 828 27 DownloadDb::server_add_file 0 1 352 10
/**
 *
 */
72
void DownloadDb::server_add_file(std::string mfname, std::string fname);

746 7 read_db 0 4 828 19 DownloadDb::read_db 0 2 353 354 22
/**
 *
 */

/**
 *
 */
148
DownloadDb::Db DownloadDb::read_db(Filename &file, bool want_server_info);
DownloadDb::Db DownloadDb::read_db(Ramfile &file, bool want_server_info);

747 8 write_db 0 4 828 20 DownloadDb::write_db 0 1 355 10
/**
 *
 */
84
bool DownloadDb::write_db(Filename &file, DownloadDb::Db db, bool want_server_info);

748 11 add_version 0 4 828 23 DownloadDb::add_version 0 1 356 176
/**
 * Appends a new version of the file onto the end of the list, or changes the
 * hash associated with a version previously added.
 *
 * Note: version numbers start at 1
 */
85
void DownloadDb::add_version(Filename const &name, HashVal const &hash, int version);

749 18 insert_new_version 0 4 828 30 DownloadDb::insert_new_version 0 1 357 97
/**
 * Inserts a new version 1 copy of the file, sliding all the other versions up
 * by one.
 */
79
void DownloadDb::insert_new_version(Filename const &name, HashVal const &hash);

750 11 has_version 0 4 828 23 DownloadDb::has_version 0 1 358 164
/**
 * Returns true if the indicated file has version information, false
 * otherwise.  Some files recorded in the database may not bother to track
 * versions.
 */
57
bool DownloadDb::has_version(Filename const &name) const;

751 16 get_num_versions 0 4 828 28 DownloadDb::get_num_versions 0 1 359 72
/**
 * Returns the number of versions stored for the indicated file.
 */
61
int DownloadDb::get_num_versions(Filename const &name) const;

752 16 set_num_versions 0 4 828 28 DownloadDb::set_num_versions 0 1 360 146
/**
 * Reduces the number of versions of a particular file stored in the ddb by
 * throwing away all versions higher than the indicated index.
 */
74
void DownloadDb::set_num_versions(Filename const &name, int num_versions);

753 11 get_version 0 4 828 23 DownloadDb::get_version 0 1 361 183
/**
 * Returns the version number of this particular file, determined by looking
 * up the hash generated from the file.  Returns -1 if the version number
 * cannot be determined.
 */
77
int DownloadDb::get_version(Filename const &name, HashVal const &hash) const;

754 8 get_hash 0 4 828 20 DownloadDb::get_hash 0 1 362 95
/**
 * Returns the MD5 hash associated with the indicated version of the indicated
 * file.
 */
77
HashVal const &DownloadDb::get_hash(Filename const &name, int version) const;

755 9 check_crc 0 1 0 9 check_crc 0 1 397 0
43
unsigned long int check_crc(Filename name);

756 11 check_adler 0 1 0 11 check_adler 0 1 398 0
45
unsigned long int check_adler(Filename name);

757 9 Extractor 0 4 830 20 Extractor::Extractor 0 1 363 10
/**
 *
 */
27
Extractor::Extractor(void);

758 10 ~Extractor 0 4 830 21 Extractor::~Extractor 0 0 10
/**
 *
 */
28
Extractor::~Extractor(void);

759 13 set_multifile 0 4 830 24 Extractor::set_multifile 0 1 364 147
/**
 * Specifies the filename of the Multifile that the Extractor will read.
 * Returns true on success, false if the mulifile name is invalid.
 */
62
bool Extractor::set_multifile(Filename const &multifile_name);

760 15 set_extract_dir 0 4 830 26 Extractor::set_extract_dir 0 1 365 192
/**
 * Specifies the directory into which all extracted subfiles will be written.
 * Relative paths of subfiles within the Multifile will be written as relative
 * paths to this directory.
 */
61
void Extractor::set_extract_dir(Filename const &extract_dir);

761 5 reset 0 4 830 16 Extractor::reset 0 1 366 132
/**
 * Interrupts the Extractor in the middle of its business and makes it ready
 * to accept a new list of subfiles to extract.
 */
28
void Extractor::reset(void);

762 15 request_subfile 0 4 830 26 Extractor::request_subfile 0 1 367 145
/**
 * Requests a particular subfile to be extracted when step() or run() is
 * called.  Returns true if the subfile exists, false otherwise.
 */
62
bool Extractor::request_subfile(Filename const &subfile_name);

763 20 request_all_subfiles 0 4 830 31 Extractor::request_all_subfiles 0 1 368 100
/**
 * Requests all subfiles in the Multifile to be extracted.  Returns the number
 * requested.
 */
42
int Extractor::request_all_subfiles(void);

764 4 step 0 4 830 15 Extractor::step 0 1 369 390
/**
 * After all of the requests have been made via request_file() or
 * request_all_subfiles(), call step() repeatedly until it stops returning
 * EU_ok.
 *
 * step() extracts the next small unit of data from the Multifile.  Returns
 * EU_ok if progress is continuing, EU_error_abort if there is a problem, or
 * EU_success when the last piece has been extracted.
 *
 * Also see run().
 */
26
int Extractor::step(void);

765 12 get_progress 0 4 830 23 Extractor::get_progress 0 1 370 66
/**
 * Returns the fraction of the Multifile extracted so far.
 */
48
PN_stdfloat Extractor::get_progress(void) const;

766 3 run 0 4 830 14 Extractor::run 0 1 371 367
/**
 * A convenience function to extract the Multifile all at once, when you don't
 * care about doing it in the background.
 *
 * First, call request_file() or request_all_files() to specify the files you
 * would like to extract, then call run() to do the extraction.  Also see
 * step() for when you would like the extraction to happen as a background
 * task.
 */
26
bool Extractor::run(void);

767 15 MultiplexStream 0 4 831 32 MultiplexStream::MultiplexStream 0 1 372 10
/**
 *
 */
46
inline MultiplexStream::MultiplexStream(void);

768 11 add_ostream 0 4 831 28 MultiplexStream::add_ostream 0 1 373 134
/**
 * Adds the indicated generic ostream to the multiplex output.  The ostream
 * will receive whatever data is sent to the pipe.
 */
87
inline void MultiplexStream::add_ostream(std::ostream *out, bool delete_later = false);

769 14 add_stdio_file 0 4 831 31 MultiplexStream::add_stdio_file 0 1 374 104
/**
 * Adds the given file, previously opened using the C stdio library, to the
 * multiplex output.
 */
78
inline bool MultiplexStream::add_stdio_file(FILE *file, bool close_when_done);

770 19 add_standard_output 0 4 831 36 MultiplexStream::add_standard_output 0 1 375 44
/**
 * Adds the standard output channel.
 */
55
inline void MultiplexStream::add_standard_output(void);

771 8 add_file 0 4 831 25 MultiplexStream::add_file 0 1 376 159
/**
 * Adds the given file to the multiplex output.  The file is opened in append
 * mode with line buffering.  Returns false if the file cannot be opened.
 */
53
inline bool MultiplexStream::add_file(Filename file);

772 16 add_system_debug 0 4 831 33 MultiplexStream::add_system_debug 0 1 377 247
/**
 * Adds the system debug output the the multiplex output.  This may map to a
 * syslog or some such os-specific output system.  It may do nothing on a
 * particular system.
 *
 * Presently, this maps only to OutputDebugString() on Windows.
 */
52
inline void MultiplexStream::add_system_debug(void);

773 5 flush 0 4 831 22 MultiplexStream::flush 0 1 378 62
/**
 * Forces out all output that hasn't yet been written.
 */
41
inline void MultiplexStream::flush(void);

774 16 ~MultiplexStream 0 4 831 33 MultiplexStream::~MultiplexStream 0 0 0
40
MultiplexStream::~MultiplexStream(void);

775 14 get_class_type 0 4 832 31 VirtualFileHTTP::get_class_type 0 1 379 0
56
static TypeHandle VirtualFileHTTP::get_class_type(void);

776 20 VirtualFileMountHTTP 0 4 834 42 VirtualFileMountHTTP::VirtualFileMountHTTP 0 1 380 10
/**
 *
 */
122
explicit VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http = HTTPClient::get_global_ptr());

777 15 get_http_client 0 4 834 37 VirtualFileMountHTTP::get_http_client 0 1 381 72
/**
 * Returns the HTTPClient object that services this mount point.
 */
69
inline HTTPClient *VirtualFileMountHTTP::get_http_client(void) const;

778 8 get_root 0 4 834 30 VirtualFileMountHTTP::get_root 0 1 382 72
/**
 * Returns the URL that represents the root of this mount point.
 */
65
inline URLSpec const &VirtualFileMountHTTP::get_root(void) const;

779 20 reload_vfs_mount_url 0 4 834 42 VirtualFileMountHTTP::reload_vfs_mount_url 0 1 383 396
/**
 * Reads all of the vfs-mount-url lines in the Config.prc file and replaces
 * the mount settings to match them.
 *
 * This will mount any url's mentioned in the config file, and unmount and
 * unmount any url's no longer mentioned in the config file.  Normally, it is
 * called automatically at startup, and need not be called again, unless you
 * have fiddled with some config settings.
 */
61
static void VirtualFileMountHTTP::reload_vfs_mount_url(void);

780 14 get_class_type 0 4 834 36 VirtualFileMountHTTP::get_class_type 0 1 384 0
61
static TypeHandle VirtualFileMountHTTP::get_class_type(void);

781 7 Patcher 0 4 836 16 Patcher::Patcher 0 3 385 386 387 22
/**
 *
 */

/**
 *
 */
130
Patcher::Patcher(void);
explicit Patcher::Patcher(PointerTo< Buffer > buffer);
inline Patcher::Patcher(Patcher const &) = default;

782 8 ~Patcher 0 6 836 17 Patcher::~Patcher 0 0 10
/**
 *
 */
32
virtual Patcher::~Patcher(void);

783 8 initiate 0 4 836 17 Patcher::initiate 0 1 388 10
/**
 *
 */
57
int Patcher::initiate(Filename &patch, Filename &infile);

784 3 run 0 4 836 12 Patcher::run 0 1 389 10
/**
 *
 */
23
int Patcher::run(void);

785 12 get_progress 0 4 836 21 Patcher::get_progress 0 1 390 10
/**
 *
 */
53
inline PN_stdfloat Patcher::get_progress(void) const;

786 12 StringStream 0 4 837 26 StringStream::StringStream 0 2 391 392 102
/**
 *
 */

/**
 * This version of the constructor preloads the buffer with the indicated
 * data.
 */
86
StringStream::StringStream(PyObject *source);
inline StringStream::StringStream(void);

787 10 clear_data 0 4 837 24 StringStream::clear_data 0 1 393 30
/**
 * Empties the buffer.
 */
43
inline void StringStream::clear_data(void);

788 13 get_data_size 0 4 837 27 StringStream::get_data_size 0 1 394 86
/**
 * Returns the number of characters available to be read from the data stream.
 */
53
inline std::size_t StringStream::get_data_size(void);

789 8 get_data 0 4 837 22 StringStream::get_data 0 1 395 63
/**
 * Returns the contents of the data stream as a string.
 */
39
PyObject *StringStream::get_data(void);

790 8 set_data 0 4 837 22 StringStream::set_data 0 1 396 168
/**
 * Replaces the contents of the data stream.  This implicitly reseeks to 0.
 */

/**
 * Replaces the contents of the data stream.  This implicitly reseeks to 0.
 */
44
void StringStream::set_data(PyObject *data);

791 13 ~StringStream 0 4 837 27 StringStream::~StringStream 0 0 0
34
StringStream::~StringStream(void);

398
1 0 0 6 3 806 0 0 253 /**
 * Receives a datagram over the socket by expecting a little-endian 16-bit
 * byte count as a prefix.  If the socket stream is non-blocking, may return
 * false if the data is not available; otherwise, returns false only if the
 * socket closes.
 */ 2 4 this 3 841  2 dg 1 842  
2 0 0 6 4 806 0 0 0 1 4 this 3 841  
3 0 0 4 5 844 0 0 0 1 4 this 3 841  
4 0 0 4 6 844 0 0 269 /**
 * Sets the header size for datagrams.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */ 2 4 this 3 841  15 tcp_header_size 1 845  
5 0 0 6 7 845 0 0 77 /**
 * Returns the header size for datagrams.  See set_tcp_header_size().
 */ 1 4 this 3 846  
6 0 0 6 10 806 0 0 234 /**
 * Transmits the indicated datagram over the socket by prepending it with a
 * little-endian 16-bit byte count.  Does not return until the data is sent or
 * the connection is closed, even if the socket stream is non-blocking.
 */ 2 4 this 3 848  2 dg 1 849  
7 0 0 6 11 806 0 0 0 1 4 this 3 848  
8 0 0 4 12 844 0 0 0 1 4 this 3 848  
9 0 0 4 13 844 0 0 719 /**
 * Enables or disables "collect-tcp" mode.  In this mode, individual TCP
 * packets are not sent immediately, but rather they are collected together
 * and accumulated to be sent periodically as one larger TCP packet.  This
 * cuts down on overhead from the TCP/IP protocol, especially if many small
 * packets need to be sent on the same connection, but it introduces
 * additional latency (since packets must be held before they can be sent).
 *
 * See set_collect_tcp_interval() to specify the interval of time for which to
 * hold packets before sending them.
 *
 * If you enable this mode, you may also need to periodically call
 * consider_flush() to flush the queue if no packets have been sent recently.
 */ 2 4 this 3 848  11 collect_tcp 1 806  
10 0 0 6 14 806 0 0 85 /**
 * Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().
 */ 1 4 this 3 851  
11 0 0 4 15 844 0 0 231 /**
 * Specifies the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */ 2 4 this 3 848  8 interval 1 853  
12 0 0 6 16 853 0 0 229 /**
 * Returns the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */ 1 4 this 3 851  
13 0 0 4 17 844 0 0 269 /**
 * Sets the header size for datagrams.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */ 2 4 this 3 848  15 tcp_header_size 1 845  
14 0 0 6 18 845 0 0 77 /**
 * Returns the header size for datagrams.  See set_tcp_header_size().
 */ 1 4 this 3 851  
15 0 0 6 19 806 0 0 143 /**
 * Sends the most recently queued data if enough time has elapsed.  This only
 * has meaning if set_collect_tcp() has been set to true.
 */ 1 4 this 3 848  
16 0 0 6 20 806 0 0 120 /**
 * Sends the most recently queued data now.  This only has meaning if
 * set_collect_tcp() has been set to true.
 */ 1 4 this 3 848  
17 0 0 6 29 806 0 0 0 1 4 this 3 854  
18 0 0 4 30 844 0 0 0 1 4 this 3 854  
19 0 0 6 31 796 0 0 0 1 4 this 3 854  
20 0 0 6 23 855 0 0 0 1 4 this 3 854  
21 0 0 6 25 841 0 0 0 1 4 this 3 854  
22 0 0 6 38 806 0 0 0 1 4 this 3 856  
23 0 0 4 39 844 0 0 0 1 4 this 3 856  
24 0 0 6 40 806 0 0 120 /**
 * Sends the most recently queued data now.  This only has meaning if
 * set_collect_tcp() has been set to true.
 */ 1 4 this 3 856  
25 0 0 6 34 857 0 0 0 1 4 this 3 856  
26 0 0 6 36 848 0 0 0 1 4 this 3 856  
27 0 0 6 50 806 0 0 0 1 4 this 3 858  
28 0 0 4 51 844 0 0 0 1 4 this 3 858  
29 0 0 4 52 844 0 0 269 /**
 * Sets the header size for datagrams.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */ 2 4 this 3 858  15 tcp_header_size 1 845  
30 0 0 6 53 845 0 0 77 /**
 * Returns the header size for datagrams.  See set_tcp_header_size().
 */ 1 4 this 3 859  
31 0 0 6 54 806 0 0 120 /**
 * Sends the most recently queued data now.  This only has meaning if
 * set_collect_tcp() has been set to true.
 */ 1 4 this 3 858  
32 0 0 6 44 861 0 0 0 1 4 this 3 858  
33 0 0 6 46 841 0 0 0 1 4 this 3 858  
34 0 0 6 48 848 0 0 0 1 4 this 3 858  
35 0 0 7 57 862 495 0 10 /**
 *
 */ 0 
36 0 0 7 57 862 495 0 0 1 6 param0 0 863  
37 0 0 7 57 862 495 0 135 /**
 * Creates a URLSpec by appending a path to the end of the old URLSpec,
 * inserting an intervening forward slash if necessary.
 */ 2 3 url 1 863  4 path 1 864  
38 0 0 7 57 862 495 0 10 /**
 *
 */ 2 3 url 1 867  20 server_name_expected 1 806  
39 0 0 6 58 862 0 0 0 2 4 this 3 862  3 url 1 867  
40 0 0 6 59 806 0 0 0 2 4 this 3 863  5 other 1 863  
41 0 0 6 60 806 0 0 0 2 4 this 3 863  5 other 1 863  
42 0 0 6 61 806 0 0 0 2 4 this 3 863  5 other 1 863  
43 0 0 6 62 845 0 0 158 /**
 * Returns a number less than zero if this URLSpec sorts before the other one,
 * greater than zero if it sorts after, or zero if they are equivalent.
 */ 2 4 this 3 863  5 other 1 863  
44 0 0 6 63 868 0 0 10 /**
 *
 */ 1 4 this 3 863  
45 0 0 6 64 806 0 0 90 /**
 * Returns true if the URL specifies a scheme (e.g.  "http:"), false
 * otherwise.
 */ 1 4 this 3 863  
46 0 0 6 65 806 0 0 124 /**
 * Returns true if the URL specifies an authority (this includes username,
 * server, and/or port), false otherwise.
 */ 1 4 this 3 863  
47 0 0 6 66 806 0 0 94 /**
 * Returns true if the URL specifies a username (and/or password), false
 * otherwise.
 */ 1 4 this 3 863  
48 0 0 6 67 806 0 0 76 /**
 * Returns true if the URL specifies a server name, false otherwise.
 */ 1 4 this 3 863  
49 0 0 6 68 806 0 0 76 /**
 * Returns true if the URL specifies a port number, false otherwise.
 */ 1 4 this 3 863  
50 0 0 6 69 806 0 0 146 /**
 * Returns true if the URL includes a path specification (that is, the
 * particular filename on the server to retrieve), false otherwise.
 */ 1 4 this 3 863  
51 0 0 6 70 806 0 0 83 /**
 * Returns true if the URL includes a query specification, false otherwise.
 */ 1 4 this 3 863  
52 0 0 6 71 867 0 0 97 /**
 * Returns the scheme specified by the URL, or empty string if no scheme is
 * specified.
 */ 1 4 this 3 863  
53 0 0 6 72 867 0 0 149 /**
 * Returns the authority specified by the URL (this includes username, server,
 * and/or port), or empty string if no authority is specified.
 */ 1 4 this 3 863  
54 0 0 6 73 867 0 0 194 /**
 * Returns the username specified by the URL, if any.  This might also include
 * a password, e.g.  "username:password", although putting a password on the
 * URL is probably a bad idea.
 */ 1 4 this 3 863  
55 0 0 6 74 867 0 0 137 /**
 * Returns the server name specified by the URL, if any.  In case of an IPv6
 * address, does not include the enclosing brackets.
 */ 1 4 this 3 863  
56 0 0 6 75 867 0 0 204 /**
 * Returns the port specified by the URL as a string, or the empty string if
 * no port is specified.  Compare this with get_port(), which returns a
 * default port number if no port is specified.
 */ 1 4 this 3 863  
57 0 0 6 76 804 0 0 97 /**
 * Returns the port number specified by the URL, or the default port if not
 * specified.
 */ 1 4 this 3 863  
58 0 0 6 77 867 0 0 298 /**
 * Returns a string consisting of the server name, followed by a colon,
 * followed by the port number.  If the port number is not explicitly given in
 * the URL, this string will include the implicit port number.
 * If the server is an IPv6 address, it will be enclosed in square brackets.
 */ 1 4 this 3 863  
59 0 0 6 78 806 0 0 181 /**
 * Returns true if the port number encoded in this URL is the default port
 * number for the scheme (or if there is no port number), or false if it is a
 * nonstandard port.
 */ 1 4 this 3 863  
60 0 0 6 79 845 0 0 106 /**
 * Returns the default port number for the indicated scheme, or 0 if there is
 * no known default.
 */ 1 6 scheme 1 867  
61 0 0 6 80 867 0 0 81 /**
 * Returns the path specified by the URL, or "/" if no path is specified.
 */ 1 4 this 3 863  
62 0 0 6 81 867 0 0 95 /**
 * Returns the query specified by the URL, or empty string if no query is
 * specified.
 */ 1 4 this 3 863  
63 0 0 6 82 867 0 0 106 /**
 * Returns the path (or "/" if no path is specified), followed by the query if
 * it is specified.
 */ 1 4 this 3 863  
64 0 0 6 83 806 0 0 115 /**
 * Returns true if the URL's scheme specifies an SSL-secured protocol such as
 * https, or false otherwise.
 */ 1 4 this 3 863  
65 0 0 6 84 867 0 0 50 /**
 * Returns the complete URL specification.
 */ 1 4 this 3 863  
66 0 0 4 85 844 0 0 61 /**
 * Replaces the scheme part of the URL specification.
 */ 2 4 this 3 862  6 scheme 1 867  
67 0 0 4 86 844 0 0 114 /**
 * Replaces the authority part of the URL specification.  This includes the
 * username, server, and port.
 */ 2 4 this 3 862  9 authority 1 867  
68 0 0 4 87 844 0 0 63 /**
 * Replaces the username part of the URL specification.
 */ 2 4 this 3 862  8 username 1 867  
69 0 0 4 88 844 0 0 174 /**
 * Replaces the server part of the URL specification.
 * Unlike set_server_and_port, this method does not require IPv6 addresses to
 * be enclosed in square brackets.
 */ 2 4 this 3 862  6 server 1 867  
70 0 0 4 89 844 0 0 59 /**
 * Replaces the port part of the URL specification.
 */ 2 4 this 3 862  4 port 1 867  
71 0 0 4 89 844 0 0 91 /**
 * Replaces the port part of the URL specification, given a numeric port
 * number.
 */ 2 4 this 3 862  4 port 1 804  
72 0 0 4 90 844 0 0 254 /**
 * Replaces the server and port parts of the URL specification simultaneously.
 * The input string should be of the form "server:port", or just "server" to
 * make the port number implicit.
 * Any IPv6 address must be enclosed in square brackets.
 */ 2 4 this 3 862  15 server_and_port 1 867  
73 0 0 4 91 844 0 0 59 /**
 * Replaces the path part of the URL specification.
 */ 2 4 this 3 862  4 path 1 867  
74 0 0 4 92 844 0 0 60 /**
 * Replaces the query part of the URL specification.
 */ 2 4 this 3 862  5 query 1 867  
75 0 0 4 93 844 0 0 191 /**
 * Completely replaces the URL with the indicated string.  If
 * server_name_expected is true, it is a hint that an undecorated URL is
 * probably a server name, not a local filename.
 */ 3 4 this 3 862  3 url 1 867  20 server_name_expected 1 806  
76 0 0 6 95 867 0 0 10 /**
 *
 */ 1 4 this 3 863  
77 0 0 6 96 806 0 0 98 /**
 * Returns false if the URLSpec is valid (not empty), or true if it is an
 * empty string.
 */ 1 4 this 3 863  
78 0 0 6 98 868 0 0 10 /**
 *
 */ 1 4 this 3 863  
79 0 0 6 99 868 0 0 10 /**
 *
 */ 1 4 this 3 863  
80 0 0 6 100 870 0 0 0 2 4 this 3 863  1 n 1 868  
81 0 0 6 101 806 0 0 10 /**
 *
 */ 2 4 this 3 862  2 in 1 855  
82 0 0 4 102 844 0 0 10 /**
 *
 */ 2 4 this 3 863  3 out 1 857  
83 0 0 6 103 867 0 0 313 /**
 * Returns the source string with all "unsafe" characters quoted, making a
 * string suitable for placing in a URL.  Letters, digits, and the underscore,
 * comma, period, and hyphen characters, as well as any included in the safe
 * string, are left alone; all others are converted to hex representation.
 */ 2 6 source 1 867  4 safe 1 867  
84 0 0 6 104 867 0 0 100 /**
 * Behaves like quote() with the additional behavior of replacing spaces with
 * plus signs.
 */ 2 6 source 1 867  4 safe 1 867  
85 0 0 6 105 867 0 0 121 /**
 * Reverses the operation of quote(): converts escaped characters of the form
 * "%xx" to their ascii equivalent.
 */ 1 6 source 1 867  
86 0 0 6 106 867 0 0 169 /**
 * Reverses the operation of quote_plus(): converts escaped characters of the
 * form "%xx" to their ascii equivalent, and also converts plus signs to
 * spaces.
 */ 1 6 source 1 867  
87 0 0 6 94 867 0 0 0 1 4 this 3 863  
88 0 0 6 97 806 0 0 0 1 4 this 3 863  
89 0 0 7 125 871 497 0 0 0 
90 0 0 7 125 871 497 0 0 1 6 param0 0 872  
91 0 0 7 128 874 515 0 10 /**
 *
 */ 0 
92 0 0 7 128 874 515 0 10 /**
 *
 */ 1 4 copy 1 875  
93 0 0 7 128 874 515 0 122 /**
 * Decodes the string into a sensible date.  Returns 0 (!is_valid()) if the
 * string cannot be correctly decoded.
 */ 1 6 format 1 867  
94 0 0 7 128 874 515 0 10 /**
 *
 */ 1 4 time 1 876  
95 0 0 6 129 874 0 0 0 2 4 this 3 874  4 copy 1 875  
96 0 0 7 130 874 515 0 73 /**
 * Returns an HTTPDate that represents the current time and date.
 */ 0 
97 0 0 6 131 806 0 0 141 /**
 * Returns true if the date is meaningful, or false if it is -1 (which
 * generally indicates the source string could not be parsed.)
 */ 1 4 this 3 875  
98 0 0 6 132 867 0 0 10 /**
 *
 */ 1 4 this 3 875  
99 0 0 6 133 876 0 0 48 /**
 * Returns the date as a C time_t value.
 */ 1 4 this 3 875  
100 0 0 6 134 806 0 0 0 2 4 this 3 875  5 other 1 875  
101 0 0 6 135 806 0 0 0 2 4 this 3 875  5 other 1 875  
102 0 0 6 136 806 0 0 0 2 4 this 3 875  5 other 1 875  
103 0 0 6 137 806 0 0 0 2 4 this 3 875  5 other 1 875  
104 0 0 6 138 845 0 0 159 /**
 * Returns a number less than zero if this HTTPDate sorts before the other
 * one, greater than zero if it sorts after, or zero if they are equivalent.
 */ 2 4 this 3 875  5 other 1 875  
105 0 0 6 139 874 0 0 0 2 4 this 3 874  7 seconds 1 845  
106 0 0 6 140 874 0 0 0 2 4 this 3 874  7 seconds 1 845  
107 0 0 7 141 874 515 0 0 2 4 this 3 875  7 seconds 1 845  
108 0 0 6 142 845 0 0 0 2 4 this 3 875  5 other 1 875  
109 0 0 7 142 874 515 0 0 2 4 this 3 875  7 seconds 1 845  
110 0 0 6 143 806 0 0 10 /**
 *
 */ 2 4 this 3 874  2 in 1 855  
111 0 0 4 144 844 0 0 10 /**
 *
 */ 2 4 this 3 875  3 out 1 857  
112 0 0 7 147 878 517 0 38 /**
 * Constructs an empty cookie.
 */ 0 
113 0 0 7 147 878 517 0 0 1 6 param0 0 879  
114 0 0 7 147 878 517 0 197 /**
 * Constructs a cookie according to the indicated string, presumably the tag
 * of a Set-Cookie header.  There is no way to detect a formatting error in
 * the string with this constructor.
 */ 2 6 format 1 867  3 url 1 863  
115 0 0 7 147 878 517 0 179 /**
 * Constructs a cookie with the indicated name, path, and domain values, but
 * no other data.  This is most useful for looking up an existing cookie in
 * the HTTPClient.
 */ 3 4 name 1 867  4 path 1 867  6 domain 1 867  
116 0 0 4 149 844 0 0 10 /**
 *
 */ 2 4 this 3 878  4 name 1 867  
117 0 0 6 150 867 0 0 93 /**
 * Returns the name of the cookie.  This is the key value specified by the
 * server.
 */ 1 4 this 3 879  
118 0 0 4 151 844 0 0 10 /**
 *
 */ 2 4 this 3 878  5 value 1 867  
119 0 0 6 152 867 0 0 139 /**
 * Returns the value of the cookie.  This is the arbitrary string associated
 * with the cookie's name, as specified by the server.
 */ 1 4 this 3 879  
120 0 0 4 153 844 0 0 10 /**
 *
 */ 2 4 this 3 878  6 domain 1 867  
121 0 0 6 154 867 0 0 10 /**
 *
 */ 1 4 this 3 879  
122 0 0 4 155 844 0 0 10 /**
 *
 */ 2 4 this 3 878  4 path 1 867  
123 0 0 6 156 867 0 0 99 /**
 * Returns the prefix of the URL paths on the server for which this cookie
 * will be sent.
 */ 1 4 this 3 879  
124 0 0 4 157 844 0 0 10 /**
 *
 */ 2 4 this 3 878  7 expires 1 875  
125 0 0 4 158 844 0 0 53 /**
 * Removes the expiration date on the cookie.
 */ 1 4 this 3 878  
126 0 0 6 159 806 0 0 78 /**
 * Returns true if the cookie has an expiration date, false otherwise.
 */ 1 4 this 3 879  
127 0 0 7 160 874 515 0 102 /**
 * Returns the expiration date of the cookie if it is set, or an invalid date
 * if it is not.
 */ 1 4 this 3 879  
128 0 0 4 161 844 0 0 10 /**
 *
 */ 2 4 this 3 878  4 flag 1 806  
129 0 0 6 162 806 0 0 129 /**
 * Returns true if the server has indicated this is a "secure" cookie which
 * should only be sent over an HTTPS channel.
 */ 1 4 this 3 879  
130 0 0 6 163 806 0 0 0 2 4 this 3 879  5 other 1 879  
131 0 0 4 164 844 0 0 358 /**
 * Assuming the operator < method, above, has already evaluated these two
 * cookies as equal, then assign the remaining values (value, expiration date,
 * secure flag) from the indicated cookie.  This is guaranteed not to change
 * the ordering of the cookie in a set, and so can be used to update an
 * existing cookie within a set with new values.
 */ 2 4 this 3 878  5 other 1 879  
132 0 0 6 165 806 0 0 218 /**
 * Separates out the parameter/value pairs of the Set-Cookie header and
 * assigns the values of the cookie appropriate.  Returns true if the header
 * is parsed correctly, false if something is not understood.
 */ 3 4 this 3 878  6 format 1 867  3 url 1 863  
133 0 0 6 166 806 0 0 105 /**
 * Returns true if the cookie's expiration date is before the indicated date,
 * false otherwise.
 */ 2 4 this 3 879  3 now 1 875  
134 0 0 6 167 806 0 0 112 /**
 * Returns true if the cookie is appropriate to send with the indicated URL
 * request, false otherwise.
 */ 2 4 this 3 879  3 url 1 863  
135 0 0 4 168 844 0 0 10 /**
 *
 */ 2 4 this 3 879  3 out 1 857  
136 0 0 7 171 881 0 0 10 /**
 *
 */ 0 
137 0 0 7 171 881 0 0 10 /**
 *
 */ 1 4 copy 1 882  
138 0 0 7 172 881 0 0 0 2 4 this 3 881  4 copy 1 882  
139 0 0 4 173 844 0 0 561 /**
 * This may be called once, presumably at the beginning of an application, to
 * initialize OpenSSL's random seed.  On Windows, it is particularly important
 * to call this at startup if you are going to be performing any https
 * operations or otherwise use encryption, since the Windows algorithm for
 * getting a random seed takes 2-3 seconds at startup, but can take 30 seconds
 * or more after you have opened a 3-D graphics window and started rendering.
 *
 * There is no harm in calling this method multiple times, or in not calling
 * it at all.
 */ 0 
140 0 0 4 174 844 0 0 511 /**
 * Specifies the complete set of proxies to use for all schemes.  This is
 * either a semicolon-delimited set of hostname:ports, or a semicolon-
 * delimited set of pairs of the form "scheme=hostname:port", or a
 * combination.  Use the keyword DIRECT, or an empty string, to represent a
 * direct connection.  A particular scheme and/or proxy host may be listed
 * more than once.  This is a convenience function that can be used in place
 * of explicit calls to add_proxy() for each scheme/proxy pair.
 */ 2 4 this 3 881  10 proxy_spec 1 867  
141 0 0 6 175 867 0 0 371 /**
 * Returns the complete set of proxies to use for all schemes.  This is a
 * string of the form specified by set_proxy_spec(), above.  Note that the
 * string returned by this function may not be exactly the same as the string
 * passed into set_proxy_spec(), since the string is regenerated from the
 * internal storage structures and may therefore be reordered.
 */ 1 4 this 3 882  
142 0 0 4 176 844 0 0 197 /**
 * Specifies the set of hosts that should be connected to directly, without
 * using a proxy.  This is a semicolon-separated list of hostnames that may
 * contain wildcard characters ("*").
 */ 2 4 this 3 881  16 direct_host_spec 1 867  
143 0 0 6 177 867 0 0 189 /**
 * Returns the set of hosts that should be connected to directly, without
 * using a proxy, as a semicolon-separated list of hostnames that may contain
 * wildcard characters ("*").
 */ 1 4 this 3 882  
144 0 0 4 178 844 0 0 306 /**
 * If this is set true, then after a connection attempt through a proxy fails,
 * we always try a direct connection, regardless of whether the host is listed
 * on the direct_host_spec list.  If this is false, a direct attempt is not
 * made when we have a proxy in effect, even if the proxy fails.
 */ 2 4 this 3 881  14 try_all_direct 1 806  
145 0 0 6 179 806 0 0 134 /**
 * Returns whether a failed connection through a proxy will be followed up by
 * a direct connection attempt, false otherwise.
 */ 1 4 this 3 882  
146 0 0 4 180 844 0 0 128 /**
 * Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be
 * made to build up the set of proxy servers.
 */ 1 4 this 3 881  
147 0 0 4 181 844 0 0 271 /**
 * Adds the indicated proxy host as a proxy for communications on the given
 * scheme.  Usually the scheme is "http" or "https".  It may be the empty
 * string to indicate a general proxy.  The proxy string may be the empty URL
 * to indicate a direct connection.
 */ 3 4 this 3 881  6 scheme 1 867  5 proxy 1 863  
148 0 0 4 182 844 0 0 178 /**
 * Resets the set of direct hosts to empty.  Subsequent calls to
 * add_direct_host() may be made to build up the list of hosts that do not
 * require a proxy connection.
 */ 1 4 this 3 881  
149 0 0 4 183 844 0 0 223 /**
 * Adds the indicated name to the set of hostnames that are connected to
 * directly, without using a proxy.  This name may be either a DNS name or an
 * IP address, and it may include the * as a wildcard character.
 */ 2 4 this 3 881  8 hostname 1 867  
150 0 0 6 184 867 0 0 218 /**
 * Returns a semicolon-delimited list of proxies, in the order in which they
 * should be tried, that are appropriate for the indicated URL.  The keyword
 * DIRECT indicates a direct connection should be tried.
 */ 2 4 this 3 882  3 url 1 863  
151 0 0 4 185 844 0 0 433 /**
 * Specifies the username:password string corresponding to a particular server
 * and/or realm, when demanded by the server.  Either or both of the server or
 * realm may be empty; if so, they match anything.  Also, the server may be
 * set to the special string `"*proxy"`, which will match any proxy server.
 *
 * If the username is set to the empty string, this clears the password for
 * the particular server/realm pair.
 */ 4 4 this 3 881  6 server 1 867  5 realm 1 867  8 username 1 867  
152 0 0 6 186 867 0 0 144 /**
 * Returns the username:password string set for this server/realm pair, or
 * empty string if nothing has been set.  See set_username().
 */ 3 4 this 3 882  6 server 1 867  5 realm 1 867  
153 0 0 4 187 844 0 0 116 /**
 * Stores the indicated cookie in the client's list of cookies, as if it had
 * been received from a server.
 */ 2 4 this 3 881  6 cookie 1 879  
154 0 0 6 188 806 0 0 175 /**
 * Removes the cookie with the matching domain/path/name from the client's
 * list of cookies.  Returns true if it was removed, false if the cookie was
 * not matched.
 */ 2 4 this 3 881  6 cookie 1 879  
155 0 0 4 189 844 0 0 58 /**
 * Removes the all stored cookies from the client.
 */ 1 4 this 3 881  
156 0 0 6 190 806 0 0 124 /**
 * Returns true if there is a cookie in the client matching the given cookie's
 * domain/path/name, false otherwise.
 */ 2 4 this 3 882  6 cookie 1 879  
157 0 0 7 191 878 517 0 163 /**
 * Looks up and returns the cookie in the client matching the given cookie's
 * domain/path/name.  If there is no matching cookie, returns an empty cookie.
 */ 2 4 this 3 882  6 cookie 1 879  
158 0 0 4 192 844 0 0 179 /**
 * Copies all the cookies from the indicated HTTPClient into this one.
 * Existing cookies in this client are not affected, unless they are shadowed
 * by the new cookies.
 */ 2 4 this 3 881  5 other 1 882  
159 0 0 4 193 844 0 0 172 /**
 * Outputs the complete list of cookies stored on the client, for all domains,
 * including the expired cookies (which will normally not be sent back to a
 * host).
 */ 2 4 this 3 882  3 out 1 857  
160 0 0 4 194 844 0 0 192 /**
 * Writes to the indicated ostream a "Cookie" header line for sending the
 * cookies appropriate to the indicated URL along with an HTTP request.  This
 * also removes expired cookies.
 */ 3 4 this 3 881  3 out 1 857  3 url 1 863  
161 0 0 4 195 844 0 0 250 /**
 * Sets the filename of the pem-formatted file that will be read for the
 * client public and private keys if an SSL server requests a certificate.
 * Either this or set_client_certificate_pem() may be used to specify a client
 * certificate.
 */ 2 4 this 3 881  8 filename 1 864  
162 0 0 4 196 844 0 0 264 /**
 * Sets the pem-formatted contents of the certificate that will be parsed for
 * the client public and private keys if an SSL server requests a certificate.
 * Either this or set_client_certificate_filename() may be used to specify a
 * client certificate.
 */ 2 4 this 3 881  3 pem 1 867  
163 0 0 4 197 844 0 0 160 /**
 * Sets the passphrase used to decrypt the private key in the certificate
 * named by set_client_certificate_filename() or set_client_certificate_pem().
 */ 2 4 this 3 881  10 passphrase 1 867  
164 0 0 6 198 806 0 0 376 /**
 * Attempts to load the certificate named by set_client_certificate_filename()
 * immediately, and returns true if successful, false otherwise.
 *
 * Normally this need not be explicitly called, since it will be called
 * automatically if the server requests a certificate, but it may be useful to
 * determine ahead of time if the certificate can be loaded correctly.
 */ 1 4 this 3 881  
165 0 0 6 199 806 0 0 547 /**
 * Adds the certificate defined in the indicated PEM filename as a "pre-
 * approved" certificate for the indicated server, defined by the hostname and
 * port (only) from the given URL.
 *
 * If the server offers this particular certificate on a secure connection, it
 * will be accepted without question.  This is particularly useful for
 * communicating with a server using a known self-signed certificate.
 *
 * See also the similar add_preapproved_server_certificate_pem(), and the
 * weaker add_preapproved_server_certificate_name().
 */ 3 4 this 3 881  3 url 1 863  8 filename 1 864  
166 0 0 6 200 806 0 0 577 /**
 * Adds the certificate defined in the indicated data string, formatted as a
 * PEM block, as a "pre-approved" certificate for the indicated server,
 * defined by the hostname and port (only) from the given URL.
 *
 * If the server offers this particular certificate on a secure connection, it
 * will be accepted without question.  This is particularly useful for
 * communicating with a server using a known self-signed certificate.
 *
 * See also the similar add_preapproved_server_certificate_filename(), and the
 * weaker add_preapproved_server_certificate_name().
 */ 3 4 this 3 881  3 url 1 863  3 pem 1 867  
167 0 0 6 201 806 0 0 888 /**
 * Adds the certificate *name* only, as a "pre-approved" certificate name for
 * the indicated server, defined by the hostname and port (only) from the
 * given URL.
 *
 * This is a weaker function than
 * add_preapproved_server_certificate_filename().  This checks only the
 * subject name of the certificate, without checking for a particular
 * certificate by key.  This means that a variety of server certificates may
 * match the indicated name.
 *
 * Because this is a weaker verification, it only applies to server
 * certificates that are signed by a recognized certificate authority.  Thus,
 * it cannot be used to pre-approve self-signed certificates, but it can be
 * used to accept a server certificate offered by a different hostname than
 * the one in the cert itself.
 *
 * The certificate name should be formatted in the form
 * type0=value0/type1=value1/type2=...
 */ 3 4 this 3 881  3 url 1 863  4 name 1 867  
168 0 0 4 202 844 0 0 92 /**
 * Removes all preapproved server certificates for the indicated server and
 * port.
 */ 2 4 this 3 881  3 url 1 863  
169 0 0 4 203 844 0 0 71 /**
 * Removes all preapproved server certificates for all servers.
 */ 1 4 this 3 881  
170 0 0 4 204 844 0 0 221 /**
 * Specifies the version of HTTP that the client uses to identify itself to
 * the server.  The default is HV_11, or HTTP 1.0; you can set this to HV_10
 * (HTTP 1.0) to request the server use the older interface.
 */ 2 4 this 3 881  7 version 1 808  
171 0 0 6 205 808 0 0 93 /**
 * Returns the client's current setting for HTTP version.  See
 * set_http_version().
 */ 1 4 this 3 882  
172 0 0 6 206 867 0 0 99 /**
 * Returns the current HTTP version setting as a string, e.g.  "HTTP/1.0" or
 * "HTTP/1.1".
 */ 1 4 this 3 882  
173 0 0 6 207 808 0 0 193 /**
 * Matches the string representing a particular HTTP version against any of
 * the known versions and returns the appropriate enumerated value, or
 * HV_other if the version is unknown.
 */ 1 7 version 1 867  
174 0 0 6 208 806 0 0 263 /**
 * Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and
 * -----END CERTIFICATE-----) from the indicated file and makes them known as
 * trusted public keys for validating future connections.  Returns true on
 * success, false otherwise.
 */ 2 4 this 3 881  8 filename 1 864  
175 0 0 4 210 844 0 0 263 /**
 * Specifies whether the client will insist on verifying the identity of the
 * servers it connects to via SSL (that is, https).
 *
 * The parameter value is an enumerated type which indicates the level of
 * security to which the client will insist upon.
 */ 2 4 this 3 881  10 verify_ssl 1 814  
176 0 0 6 211 814 0 0 157 /**
 * Returns whether the client will insist on verifying the identity of the
 * servers it connects to via SSL (that is, https).  See set_verify_ssl().
 */ 1 4 this 3 882  
177 0 0 4 212 844 0 0 404 /**
 * Specifies the set of ciphers that are to be made available for SSL
 * connections.  This is a string as described in the ciphers(1) man page of
 * the OpenSSL documentation (or see
 * https://www.openssl.org/docs/man1.1.1/man1/ciphers.html ).  If this isn't
 * specified, the default is provided by the Config file.  You may also specify
 * "DEFAULT" to use the built-in OpenSSL default value.
 */ 2 4 this 3 881  11 cipher_list 1 867  
178 0 0 6 213 867 0 0 93 /**
 * Returns the set of ciphers as set by set_cipher_list().  See
 * set_cipher_list().
 */ 1 4 this 3 882  
179 0 0 7 214 884 0 0 763 /**
 * Returns a new HTTPChannel object that may be used for reading multiple
 * documents using the same connection, for greater network efficiency than
 * calling HTTPClient::get_document() repeatedly (which would force a new
 * connection for each document).
 *
 * Also, HTTPChannel has some additional, less common interface methods than
 * the basic interface methods that exist on HTTPClient; if you wish to call
 * any of these methods you must first obtain an HTTPChannel.
 *
 * Pass true for persistent_connection to gain this network efficiency.  If,
 * on the other hand, your intention is to use the channel to retrieve only
 * one document, then pass false to inform the server that we will be dropping
 * the connection after the first document.
 */ 2 4 this 3 881  21 persistent_connection 1 806  
180 0 0 7 215 884 0 0 262 /**
 * Posts form data to a particular URL and retrieves the response.  Returns a
 * new HTTPChannel object whether the document is successfully read or not;
 * you can test is_valid() and get_return_code() to determine whether the
 * document was retrieved.
 */ 3 4 this 3 881  3 url 1 863  4 body 1 867  
181 0 0 7 216 884 0 0 233 /**
 * Opens the named document for reading.  Returns a new HTTPChannel object
 * whether the document is successfully read or not; you can test is_valid()
 * and get_return_code() to determine whether the document was retrieved.
 */ 2 4 this 3 881  3 url 1 863  
182 0 0 7 217 884 0 0 252 /**
 * Like get_document(), except only the header associated with the document is
 * retrieved.  This may be used to test for existence of the document; it
 * might also return the size of the document (if the server gives us this
 * information).
 */ 2 4 this 3 881  3 url 1 863  
183 0 0 6 218 867 0 0 222 /**
 * Implements HTTPAuthorization::base64_encode().  This is provided here just
 * as a convenient place to publish it for access by the scripting language;
 * C++ code should probably use HTTPAuthorization directly.
 */ 1 1 s 1 867  
184 0 0 6 219 867 0 0 222 /**
 * Implements HTTPAuthorization::base64_decode().  This is provided here just
 * as a convenient place to publish it for access by the scripting language;
 * C++ code should probably use HTTPAuthorization directly.
 */ 1 1 s 1 867  
185 0 0 7 220 881 0 0 49 /**
 * Returns the default global HTTPClient.
 */ 0 
186 0 0 7 222 885 599 0 10 /**
 *
 */ 0 
187 0 0 7 222 885 599 0 10 /**
 *
 */ 1 4 copy 1 886  
188 0 0 7 222 885 599 0 99 /**
 * This constructor accepts an explicit weak flag and a literal (not quoted)
 * tag string.
 */ 2 4 weak 1 806  3 tag 1 867  
189 0 0 7 222 885 599 0 134 /**
 * This constructor accepts a string as formatted from an HTTP server (e.g.
 * the tag is quoted, with an optional W/ prefix.)
 */ 1 4 text 1 867  
190 0 0 6 223 885 0 0 0 2 4 this 3 885  4 copy 1 886  
191 0 0 6 224 806 0 0 255 /**
 * Returns true if the entity tag is marked as "weak". A consistent weak
 * entity tag does not guarantee that its resource has not changed in any way,
 * but it does promise that the resource has not changed in any semantically
 * meaningful way.
 */ 1 4 this 3 886  
192 0 0 6 225 867 0 0 47 /**
 * Returns the tag as a literal string.
 */ 1 4 this 3 886  
193 0 0 6 226 867 0 0 126 /**
 * Returns the entity tag formatted for sending to an HTTP server (the tag is
 * quoted, with a conditional W prefix).
 */ 1 4 this 3 886  
194 0 0 6 227 806 0 0 115 /**
 * Returns true if the two tags have "strong" equivalence: they are the same
 * tag, and both are "strong".
 */ 2 4 this 3 886  5 other 1 886  
195 0 0 6 228 806 0 0 121 /**
 * Returns true if the two tags have "weak" equivalence: they are the same
 * tag, and one or both may be "weak".
 */ 2 4 this 3 886  5 other 1 886  
196 0 0 6 229 806 0 0 0 2 4 this 3 886  5 other 1 886  
197 0 0 6 230 806 0 0 0 2 4 this 3 886  5 other 1 886  
198 0 0 6 231 806 0 0 0 2 4 this 3 886  5 other 1 886  
199 0 0 6 232 845 0 0 167 /**
 * Returns a number less than zero if this HTTPEntityTag sorts before the
 * other one, greater than zero if it sorts after, or zero if they are
 * equivalent.
 */ 2 4 this 3 886  5 other 1 886  
200 0 0 4 233 844 0 0 10 /**
 *
 */ 2 4 this 3 886  3 out 1 857  
201 0 0 7 236 887 623 0 10 /**
 *
 */ 0 
202 0 0 7 236 887 623 0 10 /**
 *
 */ 1 4 copy 1 888  
203 0 0 7 236 887 623 0 10 /**
 *
 */ 1 3 url 1 863  
204 0 0 7 236 887 623 0 10 /**
 *
 */ 1 3 url 1 867  
205 0 0 6 237 887 0 0 0 2 4 this 3 887  4 copy 1 888  
206 0 0 6 238 806 0 0 0 2 4 this 3 888  5 other 1 888  
207 0 0 6 239 806 0 0 0 2 4 this 3 888  5 other 1 888  
208 0 0 6 240 806 0 0 0 2 4 this 3 888  5 other 1 888  
209 0 0 6 241 845 0 0 10 /**
 *
 */ 2 4 this 3 888  5 other 1 888  
210 0 0 4 242 844 0 0 311 /**
 * Changes the URL of the DocumentSpec without modifying its other properties.
 * Normally this would be a strange thing to do, because the tag and date are
 * usually strongly associated with the URL.  To get a DocumentSpec pointing
 * to a new URL, you would normally create a new DocumentSpec object.
 */ 2 4 this 3 887  3 url 1 863  
211 0 0 6 243 863 0 0 49 /**
 * Retrieves the URL of the DocumentSpec.
 */ 1 4 this 3 888  
212 0 0 4 244 844 0 0 69 /**
 * Changes the identity tag associated with the DocumentSpec.
 */ 2 4 this 3 887  3 tag 1 886  
213 0 0 6 245 806 0 0 79 /**
 * Returns true if an identity tag is associated with the DocumentSpec.
 */ 1 4 this 3 888  
214 0 0 6 246 886 0 0 254 /**
 * Returns the identity tag associated with the DocumentSpec, if there is one.
 * It is an error to call this if has_tag() returns false.
 *
 * The identity tag is set by the HTTP server to uniquely refer to a
 * particular version of a document.
 */ 1 4 this 3 888  
215 0 0 4 247 844 0 0 86 /**
 * Removes the identity tag associated with the DocumentSpec, if there is one.
 */ 1 4 this 3 887  
216 0 0 4 248 844 0 0 75 /**
 * Changes the last-modified date associated with the DocumentSpec.
 */ 2 4 this 3 887  4 date 1 875  
217 0 0 6 249 806 0 0 84 /**
 * Returns true if a last-modified date is associated with the DocumentSpec.
 */ 1 4 this 3 888  
218 0 0 6 250 875 0 0 153 /**
 * Returns the last-modified date associated with the DocumentSpec, if there
 * is one.  It is an error to call this if has_date() returns false.
 */ 1 4 this 3 888  
219 0 0 4 251 844 0 0 95 /**
 * Removes the last-modified date associated with the DocumentSpec, if there
 * is one.
 */ 1 4 this 3 887  
220 0 0 4 253 844 0 0 1335 /**
 * Sets the request mode of this DocumentSpec.  This is only relevant when
 * using the DocumentSpec to generate a request (for instance, in
 * HTTPChannel).  This specifies whether the document request will ask the
 * server for a newer version than the indicated version, or the exact
 * version, neither, or either.
 *
 * The possible values are:
 *
 * RM_any: ignore date and tag (if specified), and retrieve any document that
 * matches the URL.  For a subrange request, if the document matches the
 * version indicated exactly, retrieve the subrange only; otherwise, retrieve
 * the entire document.
 *
 * RM_equal: request only the precise version of the document that matches the
 * particular date and/or tag exactly, if specified; fail if this version is
 * not available.
 *
 * RM_newer: request any document that is newer than the version indicated by
 * the particular date and/or tag; fail if only that version (or older
 * versions) are available.
 *
 * RM_newer_or_equal: request any document that matches the version indicated
 * by the particular date and/or tag, or is a newer version; fail if only
 * older versions are available.
 *
 * In any of the above, you may specify either or both of the last-modified
 * date and the identity tag, whichever is known to the client.
 *
 * The default mode is RM_any.
 */ 2 4 this 3 887  12 request_mode 1 817  
221 0 0 6 254 817 0 0 82 /**
 * Returns the request mode of this DocumentSpec.  See set_request_mode().
 */ 1 4 this 3 888  
222 0 0 4 256 844 0 0 642 /**
 * Specifies what kind of cached value is acceptable for this document.
 * Warning: some HTTP proxies may not respect this setting and may return a
 * cached result anyway.
 *
 * CC_allow_cache: the normal HTTP behavior; the server may return a cached
 * value if it believes it is valid.
 *
 * CC_revalidate: a proxy is forced to contact the origin server and verify
 * that is cached value is in fact still valid before it returns it.
 *
 * CC_no_cache: a proxy must not return its cached value at all, but is forced
 * to go all the way back to the origin server for the official document.
 *
 * The default mode is CC_allow_cache.
 */ 2 4 this 3 887  13 cache_control 1 818  
223 0 0 6 257 818 0 0 83 /**
 * Returns the request mode of this DocumentSpec.  See set_cache_control().
 */ 1 4 this 3 888  
224 0 0 6 258 806 0 0 152 /**
 * Can be used to read in the DocumentSpec from a stream generated either by
 * output() or write().  Returns true on success, false on failure.
 */ 2 4 this 3 887  2 in 1 855  
225 0 0 4 259 844 0 0 10 /**
 *
 */ 2 4 this 3 888  3 out 1 857  
226 0 0 4 260 844 0 0 10 /**
 *
 */ 3 4 this 3 888  3 out 1 857  12 indent_level 1 845  
227 0 0 7 351 884 0 0 0 1 6 param0 0 890  
228 0 0 7 273 881 0 0 64 /**
 * Returns the HTTPClient object that owns this channel.
 */ 1 4 this 3 890  
229 0 0 6 274 806 0 0 126 /**
 * Returns true if the last-requested document was successfully retrieved and
 * is ready to be read, false otherwise.
 */ 1 4 this 3 890  
230 0 0 6 275 806 0 0 158 /**
 * Returns true if a connection has been established to the named server in a
 * previous call to connect_to() or begin_connect_to(), false otherwise.
 */ 1 4 this 3 890  
231 0 0 6 276 863 0 0 287 /**
 * Returns the URL that was used to retrieve the most recent document:
 * whatever URL was last passed to get_document() or get_header().  If a
 * redirect has transparently occurred, this will return the new, redirected
 * URL (the actual URL at which the document was located).
 */ 1 4 this 3 890  
232 0 0 6 277 888 0 0 380 /**
 * Returns the DocumentSpec associated with the most recent document.  This
 * includes its actual URL (following redirects) along with the identity tag
 * and last-modified date, if supplied by the server.
 *
 * This structure may be saved and used to retrieve the same version of the
 * document later, or to conditionally retrieve a newer version if it is
 * available.
 */ 1 4 this 3 890  
233 0 0 6 278 808 0 0 137 /**
 * Returns the HTTP version number returned by the server, as one of the
 * HTTPClient enumerated types, e.g.  HTTPClient::HV_11.
 */ 1 4 this 3 890  
234 0 0 6 279 867 0 0 110 /**
 * Returns the HTTP version number returned by the server, formatted as a
 * string, e.g.  "HTTP/1.1".
 */ 1 4 this 3 890  
235 0 0 6 280 845 0 0 501 /**
 * Returns the HTML return code from the document retrieval request.  This
 * will be in the 200 range if the document is successfully retrieved, or some
 * other value in the case of an error.
 *
 * Some proxy errors during an https-over-proxy request would return the same
 * status code as a different error that occurred on the host server.  To
 * differentiate these cases, status codes that are returned by the proxy
 * during the CONNECT phase (except code 407) are incremented by 1000.
 */ 1 4 this 3 890  
236 0 0 6 281 867 0 0 133 /**
 * Returns the string as returned by the server describing the status code for
 * humans.  This may or may not be meaningful.
 */ 1 4 this 3 890  
237 0 0 6 282 867 0 0 363 /**
 * If the document failed to connect because of a 401 (Authorization
 * required), this method will return the "realm" returned by the server in
 * which the requested document must be authenticated.  This string may be
 * presented to the user to request an associated username and password (which
 * then should be stored in HTTPClient::set_username()).
 */ 1 4 this 3 890  
238 0 0 6 283 867 0 0 311 /**
 * If the document failed to connect because of a 407 (Proxy authorization
 * required), this method will return the "realm" returned by the proxy.  This
 * string may be presented to the user to request an associated username and
 * password (which then should be stored in HTTPClient::set_username()).
 */ 1 4 this 3 890  
239 0 0 6 284 863 0 0 366 /**
 * If the document failed with a redirect code (300 series), this will
 * generally contain the new URL the server wants us to try.  In many cases,
 * the client will automatically follow redirects; if these are successful the
 * client will return a successful code and get_redirect() will return empty,
 * but get_url() will return the new, redirected URL.
 */ 1 4 this 3 890  
240 0 0 6 285 867 0 0 160 /**
 * Returns the HTML header value associated with the indicated key, or empty
 * string if the key was not defined in the message returned by the server.
 */ 2 4 this 3 890  3 key 1 867  
241 0 0 6 286 845 0 0 212 /**
 * If the document automatically followed one or more redirects, this will
 * return the number of redirects that were automatically followed.  Use
 * get_redirect_step() to retrieve each URL in sequence.
 */ 1 4 this 3 890  
242 0 0 6 287 863 0 0 182 /**
 * Use in conjunction with get_num_redirect_steps() to extract the chain of
 * URL's that the channel was automatically redirected through to arrive at
 * the final document.
 */ 2 4 this 3 890  1 n 1 845  
243 0 0 4 289 844 0 0 532 /**
 * Indicates whether the HTTPChannel should try to keep the connection to the
 * server open and reuse that connection for multiple documents, or whether it
 * should close the connection and open a new one for each request.  Set this
 * true to keep the connections around when possible, false to recycle them.
 *
 * It makes most sense to set this false when the HTTPChannel will be used
 * only once to retrieve a single document, true when you will be using the
 * same HTTPChannel object to retrieve multiple documents.
 */ 2 4 this 3 884  21 persistent_connection 1 806  
244 0 0 6 290 806 0 0 267 /**
 * Returns whether the HTTPChannel should try to keep the connection to the
 * server open and reuse that connection for multiple documents, or whether it
 * should close the connection and open a new one for each request.  See
 * set_persistent_connection().
 */ 1 4 this 3 890  
245 0 0 6 291 806 0 0 217 /**
 * Returns true if the server has indicated it will close the connection after
 * this document has been read, or false if it will remain open (and future
 * documents may be requested on the same connection).
 */ 1 4 this 3 890  
246 0 0 4 292 844 0 0 325 /**
 * If this is true (the normal case), the HTTPClient will be consulted for
 * information about the proxy to be used for each connection via this
 * HTTPChannel.  If this has been set to false by the user, then all
 * connections will be made directly, regardless of the proxy settings
 * indicated on the HTTPClient.
 */ 2 4 this 3 884  11 allow_proxy 1 806  
247 0 0 6 293 806 0 0 325 /**
 * If this is true (the normal case), the HTTPClient will be consulted for
 * information about the proxy to be used for each connection via this
 * HTTPChannel.  If this has been set to false by the user, then all
 * connections will be made directly, regardless of the proxy settings
 * indicated on the HTTPClient.
 */ 1 4 this 3 890  
248 0 0 4 294 844 0 0 795 /**
 * Normally, a proxy is itself asked for ordinary URL's, and the proxy decides
 * whether to hand the client a cached version of the document or to contact
 * the server for a fresh version.  The proxy may also modify the headers and
 * transfer encoding on the way.
 *
 * If this is set to true, then instead of asking for URL's from the proxy, we
 * will ask the proxy to open a connection to the server (for instance, on
 * port 80); if the proxy honors this request, then we contact the server
 * directly through this connection to retrieve the document.  If the proxy
 * does not honor the connect request, then the retrieve operation fails.
 *
 * SSL connections (e.g.  https), and connections through a Socks proxy, are
 * always tunneled, regardless of the setting of this flag.
 */ 2 4 this 3 884  12 proxy_tunnel 1 806  
249 0 0 6 295 806 0 0 172 /**
 * Returns true if connections always tunnel through a proxy, or false (the
 * normal case) if we allow the proxy to serve up documents.  See
 * set_proxy_tunnel().
 */ 1 4 this 3 890  
250 0 0 4 296 844 0 0 322 /**
 * Sets the maximum length of time, in seconds, that the channel will wait
 * before giving up on establishing a TCP connection.
 *
 * At present, this is used only for the nonblocking interfaces (e.g.
 * begin_get_document(), begin_connect_to()), but it is used whether
 * set_blocking_connect() is true or false.
 */ 2 4 this 3 884  15 timeout_seconds 1 853  
251 0 0 6 297 853 0 0 130 /**
 * Returns the length of time, in seconds, to wait for a new nonblocking
 * socket to connect.  See set_connect_timeout().
 */ 1 4 this 3 890  
252 0 0 4 298 844 0 0 641 /**
 * If this flag is true, a socket connect will block even for nonblocking I/O
 * calls like begin_get_document(), begin_connect_to(), etc.  If false, a
 * socket connect will not block for nonblocking I/O calls, but will block for
 * blocking I/O calls (get_document(), connect_to(), etc.).
 *
 * Setting this true is useful when you want to use non-blocking I/O once you
 * have established the connection, but you don't want to bother with polling
 * for the initial connection.  It's also useful when you don't particularly
 * care about non-blocking I/O, but you need to respect timeouts like
 * connect_timeout and http_timeout.
 */ 2 4 this 3 884  16 blocking_connect 1 806  
253 0 0 6 299 806 0 0 298 /**
 * If this flag is true, a socket connect will block even for nonblocking I/O
 * calls like begin_get_document(), begin_connect_to(), etc.  If false, a
 * socket connect will not block for nonblocking I/O calls, but will block for
 * blocking I/O calls (get_document(), connect_to(), etc.).
 */ 1 4 this 3 890  
254 0 0 4 300 844 0 0 485 /**
 * Sets the maximum length of time, in seconds, that the channel will wait for
 * the HTTP server to finish sending its response to our request.
 *
 * The timer starts counting after the TCP connection has been established
 * (see set_connect_timeout(), above) and the request has been sent.
 *
 * At present, this is used only for the nonblocking interfaces (e.g.
 * begin_get_document(), begin_connect_to()), but it is used whether
 * set_blocking_connect() is true or false.
 */ 2 4 this 3 884  15 timeout_seconds 1 853  
255 0 0 6 301 853 0 0 133 /**
 * Returns the length of time, in seconds, to wait for the HTTP server to
 * respond to our request.  See set_http_timeout().
 */ 1 4 this 3 890  
256 0 0 4 302 844 0 0 632 /**
 * Specifies the maximum number of bytes in a received (but unwanted) body
 * that will be skipped past, in order to reset to a new request.
 *
 * That is, if this HTTPChannel requests a file via get_document(), but does
 * not call download_to_ram(), download_to_file(), or open_read_body(), and
 * instead immediately requests a new file, then the HTTPChannel has a choice
 * whether to skip past the unwanted document, or to close the connection and
 * open a new one.  If the number of bytes to skip is more than this
 * threshold, the connection will be closed; otherwise, the data will simply
 * be read and discarded.
 */ 2 4 this 3 884  14 skip_body_size 1 868  
257 0 0 6 303 868 0 0 176 /**
 * Returns the maximum number of bytes in a received (but unwanted) body that
 * will be skipped past, in order to reset to a new request.  See
 * set_skip_body_size().
 */ 1 4 this 3 890  
258 0 0 4 304 844 0 0 387 /**
 * Specifies the amount of time, in seconds, in which a previously-established
 * connection is allowed to remain open and unused.  If a previous connection
 * has remained unused for at least this number of seconds, it will be closed
 * and a new connection will be opened; otherwise, the same connection will be
 * reused for the next request (for this particular HTTPChannel).
 */ 2 4 this 3 884  12 idle_timeout 1 853  
259 0 0 6 305 853 0 0 162 /**
 * Returns the amount of time, in seconds, in which an previously-established
 * connection is allowed to remain open and unused.  See set_idle_timeout().
 */ 1 4 this 3 890  
260 0 0 4 306 844 0 0 686 /**
 * Specifies whether nonblocking downloads (via download_to_file() or
 * download_to_ram()) will be limited so as not to use all available
 * bandwidth.
 *
 * If this is true, when a download has been started on this channel it will
 * be invoked no more frequently than get_max_updates_per_second(), and the
 * total bandwidth used by the download will be no more than
 * get_max_bytes_per_second().  If this is false, downloads will proceed as
 * fast as the server can send the data.
 *
 * This only has effect on the nonblocking I/O methods like
 * begin_get_document(), etc.  The blocking methods like get_document() always
 * use as much CPU and bandwidth as they can get.
 */ 2 4 this 3 884  17 download_throttle 1 806  
261 0 0 6 307 806 0 0 112 /**
 * Returns whether the nonblocking downloads will be bandwidth-limited.  See
 * set_download_throttle().
 */ 1 4 this 3 890  
262 0 0 4 308 844 0 0 178 /**
 * When bandwidth throttling is in effect (see set_download_throttle()), this
 * specifies the maximum number of bytes per second that may be consumed by
 * this channel.
 */ 2 4 this 3 884  20 max_bytes_per_second 1 853  
263 0 0 6 309 853 0 0 135 /**
 * Returns the maximum number of bytes per second that may be consumed by this
 * channel when get_download_throttle() is true.
 */ 1 4 this 3 890  
264 0 0 4 310 844 0 0 194 /**
 * When bandwidth throttling is in effect (see set_download_throttle()), this
 * specifies the maximum number of times per second that run() will attempt to
 * do any downloading at all.
 */ 2 4 this 3 884  22 max_updates_per_second 1 853  
265 0 0 6 311 853 0 0 134 /**
 * Returns the maximum number of times per second that run() will do anything
 * at all, when get_download_throttle() is true.
 */ 1 4 this 3 890  
266 0 0 4 312 844 0 0 127 /**
 * Specifies the Content-Type header, useful for applications that require
 * different types of content, such as JSON.
 */ 2 4 this 3 884  12 content_type 1 867  
267 0 0 6 313 867 0 0 56 /**
 * Returns the value of the Content-Type header.
 */ 1 4 this 3 890  
268 0 0 4 314 844 0 0 320 /**
 * This may be called immediately after a call to get_document() or some
 * related function to specify the expected size of the document we are
 * retrieving, if we happen to know.  This is used as the return value to
 * get_file_size() only in the case that the server does not tell us the
 * actual file size.
 */ 2 4 this 3 884  9 file_size 1 868  
269 0 0 6 315 892 0 0 506 /**
 * Returns the size of the file, if it is known.  Returns the value set by
 * set_expected_file_size() if the file size is not known, or 0 if this value
 * was not set.
 *
 * If the file is dynamically generated, the size may not be available until a
 * read has started (e.g.  open_read_body() has been called); and even then it
 * may increase as more of the file is read due to the nature of HTTP/1.1
 * requests which can change their minds midstream about how much data they're
 * sending you.
 */ 1 4 this 3 890  
270 0 0 6 316 806 0 0 327 /**
 * Returns true if the size of the file we are currently retrieving was told
 * us by the server and thus is reliably known, or false if the size reported
 * by get_file_size() represents an educated guess (possibly as set by
 * set_expected_file_size(), or as inferred from a chunked transfer encoding
 * in progress).
 */ 1 4 this 3 890  
271 0 0 6 317 868 0 0 289 /**
 * Returns the first byte of the file requested by the request.  This will
 * normally be 0 to indicate that the file is being requested from the
 * beginning, but if the file was requested via a get_subdocument() call, this
 * will contain the first_byte parameter from that call.
 */ 1 4 this 3 890  
272 0 0 6 318 868 0 0 285 /**
 * Returns the last byte of the file requested by the request.  This will
 * normally be 0 to indicate that the file is being requested to its last
 * byte, but if the file was requested via a get_subdocument() call, this will
 * contain the last_byte parameter from that call.
 */ 1 4 this 3 890  
273 0 0 6 319 868 0 0 367 /**
 * Returns the first byte of the file (that will be) delivered by the server
 * in response to the current request.  Normally, this is the same as
 * get_first_byte_requested(), but some servers will ignore a subdocument
 * request and always return the whole file, in which case this value will be
 * 0, regardless of what was requested to get_subdocument().
 */ 1 4 this 3 890  
274 0 0 6 320 868 0 0 365 /**
 * Returns the last byte of the file (that will be) delivered by the server in
 * response to the current request.  Normally, this is the same as
 * get_last_byte_requested(), but some servers will ignore a subdocument
 * request and always return the whole file, in which case this value will be
 * 0, regardless of what was requested to get_subdocument().
 */ 1 4 this 3 890  
275 0 0 4 321 844 0 0 97 /**
 * Outputs a list of all headers defined by the server to the indicated output
 * stream.
 */ 2 4 this 3 890  3 out 1 857  
276 0 0 4 322 844 0 0 538 /**
 * Stops whatever file transaction is currently in progress, closes the
 * connection, and resets to begin anew.  You shouldn't ever need to call
 * this, since the channel should be able to reset itself cleanly between
 * requests, but it is provided in case you are an especially nervous type.
 *
 * Don't call this after every request unless you set
 * set_persistent_connection() to false, since calling reset() rudely closes
 * the connection regardless of whether we have told the server we intend to
 * keep it open or not.
 */ 1 4 this 3 884  
277 0 0 4 323 844 0 0 487 /**
 * Preserves the previous status code (presumably a failure) from the previous
 * connection attempt.  If the subsequent connection attempt also fails, the
 * returned status code will be the better of the previous code and the
 * current code.
 *
 * This can be called to daisy-chain subsequent attempts to download the same
 * document from different servers.  After all servers have been attempted,
 * the final status code will reflect the attempt that most nearly succeeded.
 */ 1 4 this 3 884  
278 0 0 4 324 844 0 0 99 /**
 * Resets the extra headers that were previously added via calls to
 * send_extra_header().
 */ 1 4 this 3 884  
279 0 0 4 325 844 0 0 352 /**
 * Specifies an additional key: value pair that is added into the header sent
 * to the server with the next request.  This is passed along with no
 * interpretation by the HTTPChannel code.  You may call this repeatedly to
 * append multiple headers.
 *
 * This is persistent for one request only; it must be set again for each new
 * request.
 */ 3 4 this 3 884  3 key 1 867  5 value 1 867  
280 0 0 6 326 806 0 0 111 /**
 * Opens the named document for reading, if available.  Returns true if
 * successful, false otherwise.
 */ 2 4 this 3 884  3 url 1 888  
281 0 0 6 327 806 0 0 313 /**
 * Retrieves only the specified byte range of the indicated document.  If
 * last_byte is 0, it stands for the last byte of the document.  When a
 * subdocument is requested, get_file_size() and get_bytes_downloaded() will
 * report the number of bytes of the subdocument, not of the complete
 * document.
 */ 4 4 this 3 884  3 url 1 888  10 first_byte 1 868  9 last_byte 1 868  
282 0 0 6 328 806 0 0 252 /**
 * Like get_document(), except only the header associated with the document is
 * retrieved.  This may be used to test for existence of the document; it
 * might also return the size of the document (if the server gives us this
 * information).
 */ 2 4 this 3 884  3 url 1 888  
283 0 0 6 329 806 0 0 74 /**
 * Posts form data to a particular URL and retrieves the response.
 */ 3 4 this 3 884  3 url 1 888  4 body 1 867  
284 0 0 6 330 806 0 0 111 /**
 * Uploads the indicated body to the server to replace the indicated URL, if
 * the server allows this.
 */ 3 4 this 3 884  3 url 1 888  4 body 1 867  
285 0 0 6 331 806 0 0 59 /**
 * Requests the server to remove the indicated URL.
 */ 2 4 this 3 884  3 url 1 888  
286 0 0 6 332 806 0 0 159 /**
 * Sends a TRACE message to the server, which should return back the same
 * message as the server received it, allowing inspection of proxy hops, etc.
 */ 2 4 this 3 884  3 url 1 888  
287 0 0 6 333 806 0 0 319 /**
 * Establish a direct connection to the server and port indicated by the URL,
 * but do not issue any HTTP requests.  If successful, the connection may then
 * be taken to use for whatever purposes you like by calling get_connection().
 *
 * This establishes a blocking I/O socket.  Also see begin_connect_to().
 */ 2 4 this 3 884  3 url 1 888  
288 0 0 6 334 806 0 0 136 /**
 * Sends an OPTIONS message to the server, which should query the available
 * options, possibly in relation to a specified URL.
 */ 2 4 this 3 884  3 url 1 888  
289 0 0 4 335 844 0 0 445 /**
 * Begins a non-blocking request to retrieve a given document.  This method
 * will return immediately, even before a connection to the server has
 * necessarily been established; you must then call run() from time to time
 * until the return value of run() is false.  Then you may check is_valid()
 * and get_status_code() to determine the status of your request.
 *
 * If a previous request had been pending, that request is discarded.
 */ 2 4 this 3 884  3 url 1 888  
290 0 0 4 336 844 0 0 345 /**
 * Begins a non-blocking request to retrieve only the specified byte range of
 * the indicated document.  If last_byte is 0, it stands for the last byte of
 * the document.  When a subdocument is requested, get_file_size() and
 * get_bytes_downloaded() will report the number of bytes of the subdocument,
 * not of the complete document.
 */ 4 4 this 3 884  3 url 1 888  10 first_byte 1 868  9 last_byte 1 868  
291 0 0 4 337 844 0 0 115 /**
 * Begins a non-blocking request to retrieve a given header.  See
 * begin_get_document() and get_header().
 */ 2 4 this 3 884  3 url 1 888  
292 0 0 4 338 844 0 0 431 /**
 * Posts form data to a particular URL and retrieves the response, all using
 * non-blocking I/O.  See begin_get_document() and post_form().
 *
 * It is important to note that you *must* call run() repeatedly after calling
 * this method until run() returns false, and you may not call any other
 * document posting or retrieving methods using the HTTPChannel object in the
 * interim, or your form data may not get posted.
 */ 3 4 this 3 884  3 url 1 888  4 body 1 867  
293 0 0 6 339 806 0 0 425 /**
 * This must be called from time to time when non-blocking I/O is in use.  It
 * checks for data coming in on the socket and writes data out to the socket
 * when possible, and does whatever processing is required towards completing
 * the current task.
 *
 * The return value is true if the task is still pending (and run() will need
 * to be called again in the future), or false if the current task is
 * complete.
 */ 1 4 this 3 884  
294 0 0 4 340 844 0 0 536 /**
 * Begins a non-blocking request to establish a direct connection to the
 * server and port indicated by the URL.  No HTTP requests will be issued
 * beyond what is necessary to establish the connection.  When run() has
 * finished, you may call is_connection_ready() to determine if the connection
 * was successfully established.
 *
 * If successful, the connection may then be taken to use for whatever
 * purposes you like by calling get_connection().
 *
 * This establishes a nonblocking I/O socket.  Also see connect_to().
 */ 2 4 this 3 884  3 url 1 888  
295 0 0 6 341 854 0 0 569 /**
 * Returns a newly-allocated istream suitable for reading the body of the
 * document.  This may only be called immediately after a call to
 * get_document() or post_form(), or after a call to run() has returned false.
 *
 * Note that, in nonblocking mode, the returned stream may report an early
 * EOF, even before the actual end of file.  When this happens, you should
 * call stream->is_closed() to determine whether you should attempt to read
 * some more later.
 *
 * The user is responsible for passing the returned istream to
 * close_read_body() later.
 */ 1 4 this 3 884  
296 0 0 4 342 844 0 0 243 /**
 * Closes a file opened by a previous call to open_read_body().  This really
 * just deletes the istream pointer, but it is recommended to use this
 * interface instead of deleting it explicitly, to help work around compiler
 * issues.
 */ 2 4 this 3 890  6 stream 1 855  
297 0 0 6 343 806 0 0 1345 /**
 * Specifies the name of a file to download the resulting document to.  This
 * should be called immediately after get_document() or begin_get_document()
 * or related functions.
 *
 * In the case of the blocking I/O methods like get_document(), this function
 * will download the entire document to the file and return true if it was
 * successfully downloaded, false otherwise.
 *
 * In the case of non-blocking I/O methods like begin_get_document(), this
 * function simply indicates an intention to download to the indicated file.
 * It returns true if the file can be opened for writing, false otherwise, but
 * the contents will not be completely downloaded until run() has returned
 * false.  At this time, it is possible that a communications error will have
 * left a partial file, so is_download_complete() may be called to test this.
 *
 * If subdocument_resumes is true and the document in question was previously
 * requested as a subdocument (i.e.  get_subdocument() with a first_byte value
 * greater than zero), this will automatically seek to the appropriate byte
 * within the file for writing the output.  In this case, the file must
 * already exist and must have at least first_byte bytes in it.  If
 * subdocument_resumes is false, a subdocument will always be downloaded
 * beginning at the first byte of the file.
 */ 3 4 this 3 884  8 filename 1 864  19 subdocument_resumes 1 806  
298 0 0 6 344 806 0 0 1223 /**
 * Specifies a Ramfile object to download the resulting document to.  This
 * should be called immediately after get_document() or begin_get_document()
 * or related functions.
 *
 * In the case of the blocking I/O methods like get_document(), this function
 * will download the entire document to the Ramfile and return true if it was
 * successfully downloaded, false otherwise.
 *
 * In the case of non-blocking I/O methods like begin_get_document(), this
 * function simply indicates an intention to download to the indicated
 * Ramfile.  It returns true if the file can be opened for writing, false
 * otherwise, but the contents will not be completely downloaded until run()
 * has returned false.  At this time, it is possible that a communications
 * error will have left a partial file, so is_download_complete() may be
 * called to test this.
 *
 * If subdocument_resumes is true and the document in question was previously
 * requested as a subdocument (i.e.  get_subdocument() with a first_byte value
 * greater than zero), this will automatically seek to the appropriate byte
 * within the Ramfile for writing the output.  In this case, the Ramfile must
 * already have at least first_byte bytes in it.
 */ 3 4 this 3 884  7 ramfile 1 894  19 subdocument_resumes 1 806  
299 0 0 6 345 806 0 0 1348 /**
 * Specifies the name of an ostream to download the resulting document to.
 * This should be called immediately after get_document() or
 * begin_get_document() or related functions.
 *
 * In the case of the blocking I/O methods like get_document(), this function
 * will download the entire document to the file and return true if it was
 * successfully downloaded, false otherwise.
 *
 * In the case of non-blocking I/O methods like begin_get_document(), this
 * function simply indicates an intention to download to the indicated file.
 * It returns true if the file can be opened for writing, false otherwise, but
 * the contents will not be completely downloaded until run() has returned
 * false.  At this time, it is possible that a communications error will have
 * left a partial file, so is_download_complete() may be called to test this.
 *
 * If subdocument_resumes is true and the document in question was previously
 * requested as a subdocument (i.e.  get_subdocument() with a first_byte value
 * greater than zero), this will automatically seek to the appropriate byte
 * within the file for writing the output.  In this case, the file must
 * already exist and must have at least first_byte bytes in it.  If
 * subdocument_resumes is false, a subdocument will always be downloaded
 * beginning at the first byte of the file.
 */ 3 4 this 3 884  4 strm 1 857  19 subdocument_resumes 1 806  
300 0 0 6 346 858 0 0 351 /**
 * Returns the connection that was established via a previous call to
 * connect_to() or begin_connect_to(), or NULL if the connection attempt
 * failed or if those methods have not recently been called.
 *
 * This stream has been allocated from the free store.  It is the user's
 * responsibility to delete this pointer when finished with it.
 */ 1 4 this 3 884  
301 0 0 6 347 868 0 0 331 /**
 * Returns the number of bytes downloaded during the last (or current)
 * download_to_file() or download_to_ram operation().  This can be used in
 * conjunction with get_file_size() to report the percent complete (but be
 * careful, since get_file_size() may return 0 if the server has not told us
 * the size of the file).
 */ 1 4 this 3 890  
302 0 0 6 348 868 0 0 658 /**
 * When download throttling is in effect (set_download_throttle() has been set
 * to true) and non-blocking I/O methods (like begin_get_document()) are used,
 * this returns the number of bytes "requested" from the server so far: that
 * is, the theoretical maximum value for get_bytes_downloaded(), if the server
 * has been keeping up with our demand.
 *
 * If this number is less than get_bytes_downloaded(), then the server has not
 * been supplying bytes fast enough to meet our own download throttle rate.
 *
 * When download throttling is not in effect, or when the blocking I/O methods
 * (like get_document(), etc.) are used, this returns 0.
 */ 1 4 this 3 890  
303 0 0 6 349 806 0 0 600 /**
 * Returns true when a download_to() or download_to_ram() has executed and the
 * file has been fully downloaded.  If this still returns false after
 * processing has completed, there was an error in transmission.
 *
 * Note that simply testing is_download_complete() does not prove that the
 * requested document was successfully retrieved--you might have just
 * downloaded the "404 not found" stub (for instance) that a server would
 * provide in response to some error condition.  You should also check
 * is_valid() to prove that the file you expected has been successfully
 * retrieved.
 */ 1 4 this 3 890  
304 0 0 7 350 897 0 0 0 0 
305 0 0 7 353 898 703 0 10 /**
 *
 */ 0 
306 0 0 7 353 898 703 0 0 1 6 param0 0 899  
307 0 0 6 355 845 0 0 201 /**
 * Begins a background decompression of the named file (whose filename must
 * end in ".pz") to a new file without the .pz extension.  The source file is
 * removed after successful completion.
 */ 2 4 this 3 898  11 source_file 1 864  
308 0 0 6 355 845 0 0 162 /**
 * Begins a background decompression from the named source file to the named
 * destination file.  The source file is removed after successful completion.
 */ 3 4 this 3 898  11 source_file 1 864  9 dest_file 1 864  
309 0 0 6 356 845 0 0 227 /**
 * Called each frame to do the next bit of work in the background task.
 * Returns EU_ok if a chunk is completed but there is more to go, or
 * EU_success when we're all done.  Any other return value indicates an error.
 */ 1 4 this 3 898  
310 0 0 6 357 806 0 0 121 /**
 * Performs a foreground decompression of the named file; does not return
 * until the decompression is complete.
 */ 2 4 this 3 898  11 source_file 1 864  
311 0 0 6 357 806 0 0 152 /**
 * Does an in-memory decompression of the indicated Ramfile.  The decompressed
 * contents are written back into the same Ramfile on completion.
 */ 2 4 this 3 898  20 source_and_dest_file 1 894  
312 0 0 6 358 826 0 0 78 /**
 * Returns the ratio through the decompression step in the background.
 */ 1 4 this 3 899  
313 0 0 7 364 901 709 0 38 /**
 * Primarily used for testing.
 */ 0 
314 0 0 7 364 901 709 0 0 1 6 param0 0 902  
315 0 0 7 364 901 709 0 64 /**
 * Create a download db with these client and server dbs
 */ 2 11 server_file 1 904  11 client_file 1 904  
316 0 0 7 364 901 709 0 64 /**
 * Create a download db with these client and server dbs
 */ 2 11 server_file 1 894  11 client_file 1 904  
317 0 0 4 366 844 0 0 10 /**
 *
 */ 2 4 this 3 902  3 out 1 857  
318 0 0 4 367 844 0 0 10 /**
 *
 */ 2 4 this 3 902  3 out 1 857  
319 0 0 4 368 844 0 0 10 /**
 *
 */ 2 4 this 3 902  3 out 1 857  
320 0 0 6 369 806 0 0 24 // Write a database file 2 4 this 3 901  4 file 1 904  
321 0 0 6 370 806 0 0 10 /**
 *
 */ 2 4 this 3 901  4 file 1 904  
322 0 0 6 371 845 0 0 10 /**
 *
 */ 1 4 this 3 902  
323 0 0 6 372 845 0 0 10 /**
 *
 */ 1 4 this 3 902  
324 0 0 6 373 867 0 0 10 /**
 *
 */ 2 4 this 3 902  5 index 1 845  
325 0 0 6 374 867 0 0 10 /**
 *
 */ 2 4 this 3 902  5 index 1 845  
326 0 0 6 375 845 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
327 0 0 4 376 844 0 0 10 /**
 *
 */ 3 4 this 3 901  6 mfname 1 867  4 size 1 845  
328 0 0 6 377 845 0 0 10 /**
 *
 */ 3 4 this 3 901  6 mfname 1 867  4 size 1 845  
329 0 0 6 378 845 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
330 0 0 4 379 844 0 0 10 /**
 *
 */ 3 4 this 3 901  6 mfname 1 867  4 size 1 845  
331 0 0 6 380 905 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
332 0 0 6 381 905 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
333 0 0 4 382 844 0 0 10 /**
 *
 */ 2 4 this 3 901  6 mfname 1 867  
334 0 0 4 383 844 0 0 10 /**
 *
 */ 2 4 this 3 901  6 mfname 1 867  
335 0 0 4 384 844 0 0 10 /**
 *
 */ 2 4 this 3 901  6 mfname 1 867  
336 0 0 4 385 844 0 0 10 /**
 *
 */ 2 4 this 3 901  6 mfname 1 867  
337 0 0 6 386 845 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
338 0 0 6 387 867 0 0 10 /**
 *
 */ 3 4 this 3 902  6 mfname 1 867  5 index 1 845  
339 0 0 6 388 806 0 0 28 // Queries from the Launcher 2 4 this 3 902  6 mfname 1 867  
340 0 0 6 389 806 0 0 147 /**
 * A multifile is complete when it is completely downloaded.  Note: it may
 * already be decompressed or extracted and it is still complete
 */ 2 4 this 3 902  6 mfname 1 867  
341 0 0 6 390 806 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
342 0 0 6 391 806 0 0 10 /**
 *
 */ 2 4 this 3 902  6 mfname 1 867  
343 0 0 7 392 907 0 0 62 /**
 * Return the hash value of the file we are working on
 */ 2 4 this 3 902  6 mfname 1 867  
344 0 0 4 393 844 0 0 55 /**
 * Set the hash value of file we are working on
 */ 3 4 this 3 901  6 mfname 1 867  3 val 1 907  
345 0 0 7 394 907 0 0 51 /**
 * Return the hash value of the server file
 */ 2 4 this 3 902  6 mfname 1 867  
346 0 0 4 395 844 0 0 55 /**
 * Set the hash value of file we are working on
 */ 3 4 this 3 901  6 mfname 1 867  3 val 1 907  
347 0 0 4 396 844 0 0 27 // Operations on multifiles 2 4 this 3 901  6 mfname 1 867  
348 0 0 4 397 844 0 0 10 /**
 *
 */ 2 4 this 3 901  13 server_mfname 1 867  
349 0 0 4 398 844 0 0 10 /**
 *
 */ 2 4 this 3 901  6 mfname 1 867  
350 0 0 4 399 844 0 0 76 /**
 * Used on the server side makefiles to create a new clean server db
 */ 1 4 this 3 901  
351 0 0 4 400 844 0 0 10 /**
 *
 */ 5 4 this 3 901  6 mfname 1 867  5 phase 1 905  4 size 1 845  6 status 1 845  
352 0 0 4 401 844 0 0 10 /**
 *
 */ 3 4 this 3 901  6 mfname 1 867  5 fname 1 867  
353 0 0 7 402 909 0 0 10 /**
 *
 */ 3 4 this 3 901  4 file 1 904  16 want_server_info 1 806  
354 0 0 7 402 909 0 0 10 /**
 *
 */ 3 4 this 3 901  4 file 1 894  16 want_server_info 1 806  
355 0 0 6 403 806 0 0 10 /**
 *
 */ 4 4 this 3 901  4 file 1 904  2 db 1 909  16 want_server_info 1 806  
356 0 0 4 404 844 0 0 176 /**
 * Appends a new version of the file onto the end of the list, or changes the
 * hash associated with a version previously added.
 *
 * Note: version numbers start at 1
 */ 4 4 this 3 901  4 name 1 864  4 hash 1 910  7 version 1 845  
357 0 0 4 405 844 0 0 97 /**
 * Inserts a new version 1 copy of the file, sliding all the other versions up
 * by one.
 */ 3 4 this 3 901  4 name 1 864  4 hash 1 910  
358 0 0 6 406 806 0 0 164 /**
 * Returns true if the indicated file has version information, false
 * otherwise.  Some files recorded in the database may not bother to track
 * versions.
 */ 2 4 this 3 902  4 name 1 864  
359 0 0 6 407 845 0 0 72 /**
 * Returns the number of versions stored for the indicated file.
 */ 2 4 this 3 902  4 name 1 864  
360 0 0 4 408 844 0 0 146 /**
 * Reduces the number of versions of a particular file stored in the ddb by
 * throwing away all versions higher than the indicated index.
 */ 3 4 this 3 901  4 name 1 864  12 num_versions 1 845  
361 0 0 6 409 845 0 0 183 /**
 * Returns the version number of this particular file, determined by looking
 * up the hash generated from the file.  Returns -1 if the version number
 * cannot be determined.
 */ 3 4 this 3 902  4 name 1 864  4 hash 1 910  
362 0 0 6 410 910 0 0 95 /**
 * Returns the MD5 hash associated with the indicated version of the indicated
 * file.
 */ 3 4 this 3 902  4 name 1 864  7 version 1 845  
363 0 0 7 414 912 758 0 10 /**
 *
 */ 0 
364 0 0 6 416 806 0 0 147 /**
 * Specifies the filename of the Multifile that the Extractor will read.
 * Returns true on success, false if the mulifile name is invalid.
 */ 2 4 this 3 912  14 multifile_name 1 864  
365 0 0 4 417 844 0 0 192 /**
 * Specifies the directory into which all extracted subfiles will be written.
 * Relative paths of subfiles within the Multifile will be written as relative
 * paths to this directory.
 */ 2 4 this 3 912  11 extract_dir 1 864  
366 0 0 4 418 844 0 0 132 /**
 * Interrupts the Extractor in the middle of its business and makes it ready
 * to accept a new list of subfiles to extract.
 */ 1 4 this 3 912  
367 0 0 6 419 806 0 0 145 /**
 * Requests a particular subfile to be extracted when step() or run() is
 * called.  Returns true if the subfile exists, false otherwise.
 */ 2 4 this 3 912  12 subfile_name 1 864  
368 0 0 6 420 845 0 0 100 /**
 * Requests all subfiles in the Multifile to be extracted.  Returns the number
 * requested.
 */ 1 4 this 3 912  
369 0 0 6 421 845 0 0 390 /**
 * After all of the requests have been made via request_file() or
 * request_all_subfiles(), call step() repeatedly until it stops returning
 * EU_ok.
 *
 * step() extracts the next small unit of data from the Multifile.  Returns
 * EU_ok if progress is continuing, EU_error_abort if there is a problem, or
 * EU_success when the last piece has been extracted.
 *
 * Also see run().
 */ 1 4 this 3 912  
370 0 0 6 422 826 0 0 66 /**
 * Returns the fraction of the Multifile extracted so far.
 */ 1 4 this 3 913  
371 0 0 6 423 806 0 0 367 /**
 * A convenience function to extract the Multifile all at once, when you don't
 * care about doing it in the background.
 *
 * First, call request_file() or request_all_files() to specify the files you
 * would like to extract, then call run() to do the extraction.  Also see
 * step() for when you would like the extraction to happen as a background
 * task.
 */ 1 4 this 3 912  
372 0 0 7 426 915 774 0 10 /**
 *
 */ 0 
373 0 0 4 427 844 0 0 134 /**
 * Adds the indicated generic ostream to the multiplex output.  The ostream
 * will receive whatever data is sent to the pipe.
 */ 3 4 this 3 915  3 out 1 857  12 delete_later 1 806  
374 0 0 6 428 806 0 0 104 /**
 * Adds the given file, previously opened using the C stdio library, to the
 * multiplex output.
 */ 3 4 this 3 915  4 file 1 916  15 close_when_done 1 806  
375 0 0 4 429 844 0 0 44 /**
 * Adds the standard output channel.
 */ 1 4 this 3 915  
376 0 0 6 430 806 0 0 159 /**
 * Adds the given file to the multiplex output.  The file is opened in append
 * mode with line buffering.  Returns false if the file cannot be opened.
 */ 2 4 this 3 915  4 file 1 904  
377 0 0 4 431 844 0 0 247 /**
 * Adds the system debug output the the multiplex output.  This may map to a
 * syslog or some such os-specific output system.  It may do nothing on a
 * particular system.
 *
 * Presently, this maps only to OutputDebugString() on Windows.
 */ 1 4 this 3 915  
378 0 0 4 432 844 0 0 62 /**
 * Forces out all output that hasn't yet been written.
 */ 1 4 this 3 915  
379 0 0 7 436 897 0 0 0 0 
380 0 0 7 439 918 0 0 10 /**
 *
 */ 2 4 root 1 863  4 http 1 881  
381 0 0 7 440 881 0 0 72 /**
 * Returns the HTTPClient object that services this mount point.
 */ 1 4 this 3 919  
382 0 0 6 441 863 0 0 72 /**
 * Returns the URL that represents the root of this mount point.
 */ 1 4 this 3 919  
383 0 0 4 442 844 0 0 396 /**
 * Reads all of the vfs-mount-url lines in the Config.prc file and replaces
 * the mount settings to match them.
 *
 * This will mount any url's mentioned in the config file, and unmount and
 * unmount any url's no longer mentioned in the config file.  Normally, it is
 * called automatically at startup, and need not be called again, unless you
 * have fiddled with some config settings.
 */ 0 
384 0 0 7 443 897 0 0 0 0 
385 0 0 7 445 921 782 0 10 /**
 *
 */ 0 
386 0 0 7 445 921 782 0 0 1 6 param0 0 922  
387 0 0 7 445 921 782 0 10 /**
 *
 */ 1 6 buffer 1 924  
388 0 0 6 447 845 0 0 10 /**
 *
 */ 3 4 this 3 921  5 patch 1 904  6 infile 1 904  
389 0 0 6 448 845 0 0 10 /**
 *
 */ 1 4 this 3 921  
390 0 0 6 449 826 0 0 10 /**
 *
 */ 1 4 this 3 922  
391 0 0 7 451 926 791 0 10 /**
 *
 */ 0 
392 0 0 7 451 926 791 0 0 1 6 source 1 838  
393 0 0 4 452 844 0 0 30 /**
 * Empties the buffer.
 */ 1 4 this 3 926  
394 0 0 6 453 868 0 0 86 /**
 * Returns the number of characters available to be read from the data stream.
 */ 1 4 this 3 926  
395 0 0 6 454 838 0 0 63 /**
 * Returns the contents of the data stream as a string.
 */ 1 4 this 3 926  
396 0 0 4 455 844 0 0 0 2 4 this 3 926  4 data 1 838  
397 0 0 6 411 927 0 0 0 1 4 name 1 904  
398 0 0 6 412 927 0 0 0 1 4 name 1 904  
137
792 8 SSReader 0 26625 8 SSReader 8 SSReader 0 0 0 0 399 0 5 400 401 402 403 404 0 0 0 0 0 219
/**
 * An internal class for reading from a socket stream.  This serves as a base
 * class for both ISocketStream and SocketStream; its purpose is to minimize
 * redundant code between them.  Do not use it directly.
 */

793 8 SSWriter 0 26625 8 SSWriter 8 SSWriter 0 0 0 0 405 0 11 406 407 408 409 410 411 412 413 414 415 416 0 0 0 0 0 217
/**
 * An internal class for writing to a socket stream.  This serves as a base
 * class for both OSocketStream and SocketStream; its purpose is to minimize
 * redundant code between them.  Do not use it directly.
 */

794 13 ISocketStream 0 26625 13 ISocketStream 13 ISocketStream 0 0 0 0 421 0 3 422 423 424 0 0 2 3 795 417 418 3 792 419 420 0 1 796 278
/**
 * This is a base class for istreams implemented in Panda that read from a
 * (possibly non-blocking) socket.  It adds is_closed(), which can be called
 * after an eof condition to check whether the socket has been closed, or
 * whether more data may be available later.
 */

795 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0

796 9 ReadState 0 794624 24 ISocketStream::ReadState 24 ISocketStream::ReadState 794 0 0 0 0 0 0 0 0 0 4 10 RS_initial 25 ISocketStream::RS_initial 0
0 10 RS_reading 25 ISocketStream::RS_reading 0
1 11 RS_complete 26 ISocketStream::RS_complete 0
2 8 RS_error 23 ISocketStream::RS_error 0
3 0 0

797 13 OSocketStream 0 141313 13 OSocketStream 13 OSocketStream 0 0 0 0 432 0 3 429 430 431 0 0 2 3 798 425 426 3 793 427 428 0 0 251
/**
 * A base class for ostreams that write to a (possibly non-blocking) socket.
 * It adds is_closed(), which can be called after any write operation fails to
 * check whether the socket has been closed, or whether more data may be sent
 * later.
 */

798 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

799 12 SocketStream 0 141313 12 SocketStream 12 SocketStream 0 0 0 0 444 0 5 439 440 441 442 443 0 0 3 3 800 433 434 3 792 435 436 3 793 437 438 0 0 97
/**
 * A base class for iostreams that read and write to a (possibly non-blocking)
 * socket.
 */

800 8 iostream 0 2048 13 std::iostream 13 std::iostream 0 0 0 0 0 0 0 0 0 0 0 0 0

801 7 URLSpec 0 141313 7 URLSpec 7 URLSpec 0 0 0 1 445 495 9 929 930 931 932 933 934 935 936 937 47 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 483 484 486 487 488 489 490 491 492 493 494 0 2 482 485 0 0 0 224
/**
 * A container for a URL, e.g.  "http://server:port/path".
 *
 * The URLSpec object is similar to a Filename in that it contains logic to
 * identify the various parts of a URL and return (or modify) them separately.
 */

802 6 string 0 2105344 11 std::string 11 std::string 0 0 803 0 0 0 0 0 0 0 0 0 0

803 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

804 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 805 0 0 0 0 0 0 0 0 0 0

805 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

806 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

807 8 HTTPEnum 0 141313 8 HTTPEnum 8 HTTPEnum 0 0 0 1 496 497 0 0 0 0 0 0 2 808 809 147
/**
 * This class is just used as a namespace wrapper for some of the enumerated
 * types used by various classes within the HTTPClient family.
 */

808 11 HTTPVersion 0 794624 21 HTTPEnum::HTTPVersion 21 HTTPEnum::HTTPVersion 807 0 0 0 0 0 0 0 0 0 4 5 HV_09 15 HTTPEnum::HV_09 20
// HTTP 0.9 or older
0 5 HV_10 15 HTTPEnum::HV_10 11
// HTTP 1.0
1 5 HV_11 15 HTTPEnum::HV_11 11
// HTTP 1.1
2 8 HV_other 18 HTTPEnum::HV_other 0
3 0 0

809 6 Method 0 794624 16 HTTPEnum::Method 16 HTTPEnum::Method 807 0 0 0 0 0 0 0 0 0 8 9 M_options 19 HTTPEnum::M_options 0
0 5 M_get 15 HTTPEnum::M_get 0
1 6 M_head 16 HTTPEnum::M_head 0
2 6 M_post 16 HTTPEnum::M_post 0
3 5 M_put 15 HTTPEnum::M_put 0
4 8 M_delete 18 HTTPEnum::M_delete 0
5 7 M_trace 17 HTTPEnum::M_trace 0
6 9 M_connect 19 HTTPEnum::M_connect 0
7 0 0

810 8 HTTPDate 0 141313 8 HTTPDate 8 HTTPDate 0 0 0 1 498 515 0 16 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 0 0 0 0 0 238
/**
 * A container for an HTTP-legal time/date indication.  This can accept a
 * string from an HTTP header and will decode it into a C time_t value;
 * conversely, it can accept a time_t value and encode it for output as a
 * string.
 */

811 10 HTTPCookie 0 26625 10 HTTPCookie 10 HTTPCookie 0 0 0 1 516 517 0 20 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 0 0 0 0 0 124
/**
 * A cookie sent from an HTTP server to be stored on the client and returned
 * when the path and/or domain matches.
 */

812 10 HTTPClient 0 75777 10 HTTPClient 10 HTTPClient 0 0 0 1 538 0 0 48 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 0 0 1 0 813 0 0 0 1 814 552
/**
 * Handles contacting an HTTP server and retrieving a document.  Each
 * HTTPClient object represents a separate context, and stores its own list of
 * cookies, passwords, and certificates; however, a given HTTPClient is
 * capable of making multiple simultaneous requests to the same or different
 * servers.
 *
 * It is up to the programmer whether one HTTPClient should be used to
 * retrieve all documents, or a separate one should be created each time.
 * There is a default, global HTTPClient available in
 * HTTPClient::get_global_ptr().
 */

813 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

814 9 VerifySSL 0 794624 21 HTTPClient::VerifySSL 21 HTTPClient::VerifySSL 812 0 0 0 0 0 0 0 0 0 3 12 VS_no_verify 24 HTTPClient::VS_no_verify 28
// Don't care who we talk to
0 16 VS_no_date_check 28 HTTPClient::VS_no_date_check 53
// Must identify certs, but old, expired certs are OK
1 9 VS_normal 21 HTTPClient::VS_normal 50
// Identify certs and also check expiration dates.
2 0 0

815 13 HTTPEntityTag 0 141313 13 HTTPEntityTag 13 HTTPEntityTag 0 0 0 1 587 599 0 11 588 589 590 591 592 593 594 595 596 597 598 0 0 0 0 0 185
/**
 * A container for an "entity tag" from an HTTP server.  This is used to
 * identify a particular version of a document or resource, particularly
 * useful for verifying caches.
 */

816 12 DocumentSpec 0 141313 12 DocumentSpec 12 DocumentSpec 0 0 0 1 600 623 5 938 939 940 941 942 22 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 0 0 0 0 2 817 818 315
/**
 * A descriptor that refers to a particular version of a document.  This
 * includes the URL of the document and its identity tag and last-modified
 * dates.
 *
 * The DocumentSpec may also be used to request a newer document than a
 * particular one if available, for instance to refresh a cached document.
 */

817 11 RequestMode 0 794624 25 DocumentSpec::RequestMode 25 DocumentSpec::RequestMode 816 0 0 0 0 0 0 0 0 0 4 6 RM_any 20 DocumentSpec::RM_any 0
0 8 RM_equal 22 DocumentSpec::RM_equal 0
1 8 RM_newer 22 DocumentSpec::RM_newer 0
2 17 RM_equal_or_newer 31 DocumentSpec::RM_equal_or_newer 0
3 0 0

818 12 CacheControl 0 794624 26 DocumentSpec::CacheControl 26 DocumentSpec::CacheControl 816 0 0 0 0 0 0 0 0 0 3 14 CC_allow_cache 28 DocumentSpec::CC_allow_cache 0
0 13 CC_revalidate 27 DocumentSpec::CC_revalidate 0
1 11 CC_no_cache 25 DocumentSpec::CC_no_cache 0
2 0 0

819 13 URLSpec const 0 8832 13 URLSpec const 13 URLSpec const 0 0 801 0 0 0 0 0 0 0 0 0 0

820 19 HTTPEntityTag const 0 8832 19 HTTPEntityTag const 19 HTTPEntityTag const 0 0 815 0 0 0 0 0 0 0 0 0 0

821 14 HTTPDate const 0 8832 14 HTTPDate const 14 HTTPDate const 0 0 810 0 0 0 0 0 0 0 0 0 0

822 11 HTTPChannel 0 75777 11 HTTPChannel 11 HTTPChannel 0 0 0 1 701 0 0 77 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 1 946 0 1 0 823 0 0 0 1 824 554
/**
 * A single channel of communication from an HTTPClient.  This is similar to
 * the concept of a 'connection', except that HTTP is technically
 * connectionless; in fact, a channel may represent one unbroken connection or
 * it may transparently close and reopen a new connection with each request.
 *
 * A channel is conceptually a single thread of I/O. One document at a time
 * may be requested using a channel; a new document may (in general) not be
 * requested from the same HTTPChannel until the first document has been fully
 * retrieved.
 */

823 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

824 10 StatusCode 0 794624 23 HTTPChannel::StatusCode 23 HTTPChannel::StatusCode 822 0 0 0 0 0 0 0 0 0 20 13 SC_incomplete 26 HTTPChannel::SC_incomplete 0
0 17 SC_internal_error 30 HTTPChannel::SC_internal_error 0
1 16 SC_no_connection 29 HTTPChannel::SC_no_connection 0
2 10 SC_timeout 23 HTTPChannel::SC_timeout 0
3 18 SC_lost_connection 31 HTTPChannel::SC_lost_connection 0
4 20 SC_non_http_response 33 HTTPChannel::SC_non_http_response 0
5 15 SC_invalid_http 28 HTTPChannel::SC_invalid_http 0
6 24 SC_socks_invalid_version 37 HTTPChannel::SC_socks_invalid_version 0
7 35 SC_socks_no_acceptable_login_method 48 HTTPChannel::SC_socks_no_acceptable_login_method 0
8 16 SC_socks_refused 29 HTTPChannel::SC_socks_refused 0
9 22 SC_socks_no_connection 35 HTTPChannel::SC_socks_no_connection 0
10 23 SC_ssl_internal_failure 36 HTTPChannel::SC_ssl_internal_failure 0
11 19 SC_ssl_no_handshake 32 HTTPChannel::SC_ssl_no_handshake 0
12 23 SC_http_error_watermark 36 HTTPChannel::SC_http_error_watermark 129
// No one returns this code, but StatusCode values higher than this are
// deemed more successful than any generic HTTP response.
13 33 SC_ssl_invalid_server_certificate 46 HTTPChannel::SC_ssl_invalid_server_certificate 0
14 37 SC_ssl_self_signed_server_certificate 50 HTTPChannel::SC_ssl_self_signed_server_certificate 0
15 24 SC_ssl_unexpected_server 37 HTTPChannel::SC_ssl_unexpected_server 0
16 22 SC_download_open_error 35 HTTPChannel::SC_download_open_error 79
// These errors are only generated after a download_to_*() call been
// issued.
17 23 SC_download_write_error 36 HTTPChannel::SC_download_write_error 0
18 25 SC_download_invalid_range 38 HTTPChannel::SC_download_invalid_range 0
19 0 195
// get_status_code() will either return an HTTP-style status code >= 100
// (e.g.  404), or one of the following values.  In general, these are
// ordered from less-successful to more-successful.

825 12 Decompressor 0 26625 12 Decompressor 12 Decompressor 0 0 0 1 702 703 1 943 4 704 705 706 707 0 0 0 0 0 114
/**
 * This manages run-time decompression of a zlib-compressed stream, as a
 * background or foreground task.
 */

826 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 827 0 0 0 0 0 0 0 0 0 0

827 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

828 10 DownloadDb 0 26625 10 DownloadDb 10 DownloadDb 0 0 0 1 708 709 0 45 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 0 0 0 0 1 829 332
/**
 * A listing of files within multifiles for management of client-side
 * synchronization with a server-provided set of files.
 *
 * This class manages one copy of the database for the client, representing
 * the files on the client system, and another copy for the server,
 * representing the files the server has available.
 */

829 6 Status 0 794624 18 DownloadDb::Status 18 DownloadDb::Status 828 0 0 0 0 0 0 0 0 0 4 17 Status_incomplete 29 DownloadDb::Status_incomplete 0
0 15 Status_complete 27 DownloadDb::Status_complete 0
1 19 Status_decompressed 31 DownloadDb::Status_decompressed 0
2 16 Status_extracted 28 DownloadDb::Status_extracted 0
3 0 210
// Status of a multifile is stored in this enum Note these values are in
// increasing order of "doneness" So if you are decompressed, you are
// complete If you are extracted, you are decompressed and complete

830 9 Extractor 0 26625 9 Extractor 9 Extractor 0 0 0 1 757 758 1 944 8 759 760 761 762 763 764 765 766 0 0 0 0 0 543
/**
 * This class automatically extracts the contents of a Multifile to the
 * current directory (or to a specified directory) in the background.
 *
 * It is designed to limit its use of system resources and run unobtrusively
 * in the background.  After specifying the files you wish to extract via
 * repeated calls to request_subfile(), begin the process by calling run()
 * repeatedly.  Each call to run() extracts another small portion of the
 * Multifile.  Call run() whenever you have spare cycles until run() returns
 * EU_success.
 */

831 15 MultiplexStream 0 141313 15 MultiplexStream 15 MultiplexStream 0 0 0 1 767 774 0 6 768 769 770 771 772 773 0 0 1 0 798 0 0 0 0 291
/**
 * This is a special ostream that forwards the data that is written to it to
 * any number of other sources, for instance other ostreams, or explicitly to
 * a disk file or to system logging utilities.  It's a very handy thing to set
 * Notify to refer to when running in batch mode.
 */

832 15 VirtualFileHTTP 0 75777 15 VirtualFileHTTP 15 VirtualFileHTTP 0 0 0 0 0 0 1 775 0 0 1 0 833 0 0 0 0 155
/**
 * This maps a document retrieved from an HTTPClient into the
 * VirtualFileSystem, allowing models etc.  to be loaded directly from a web
 * page.
 */

833 11 VirtualFile 0 2048 11 VirtualFile 11 VirtualFile 0 0 0 0 0 0 0 0 0 0 0 0 91
/**
 * The abstract base class for a file or directory within the
 * VirtualFileSystem.
 */

834 20 VirtualFileMountHTTP 0 75777 20 VirtualFileMountHTTP 20 VirtualFileMountHTTP 0 0 0 1 776 0 0 4 777 778 779 780 0 0 1 0 835 0 0 0 0 65
/**
 * Maps a web page (URL root) into the VirtualFileSystem.
 */

835 16 VirtualFileMount 0 2048 16 VirtualFileMount 16 VirtualFileMount 0 0 0 0 0 0 0 0 0 0 0 0 159
/**
 * The abstract base class for a mount definition used within a
 * VirtualFileSystem.  Normally users don't need to monkey with this class
 * directly.
 */

836 7 Patcher 0 26625 7 Patcher 7 Patcher 0 0 0 1 781 782 0 3 783 784 785 0 0 0 0 0 40
/**
 * Applies a patch synchronously
 */

837 12 StringStream 0 141313 12 StringStream 12 StringStream 0 0 0 1 786 791 1 945 4 787 788 789 790 0 0 1 0 800 0 0 0 0 186
/**
 * A bi-directional stream object that reads and writes data to an internal
 * buffer, which can be retrieved and/or set as a string in Python 2 or a
 * bytes object in Python 3.
 */

838 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 839 0 0 0 0 0 0 0 0 0 0

839 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 840 0 0 0 0 0 0 0 0 0 0

840 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

841 10 SSReader * 0 8576 10 SSReader * 10 SSReader * 0 0 792 0 0 0 0 0 0 0 0 0 0

842 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 843 0 0 0 0 0 0 0 0 0 0

843 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

844 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

845 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

846 16 SSReader const * 0 8576 16 SSReader const * 16 SSReader const * 0 0 847 0 0 0 0 0 0 0 0 0 0

847 14 SSReader const 0 8832 14 SSReader const 14 SSReader const 0 0 792 0 0 0 0 0 0 0 0 0 0

848 10 SSWriter * 0 8576 10 SSWriter * 10 SSWriter * 0 0 793 0 0 0 0 0 0 0 0 0 0

849 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 850 0 0 0 0 0 0 0 0 0 0

850 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 843 0 0 0 0 0 0 0 0 0 0

851 16 SSWriter const * 0 8576 16 SSWriter const * 16 SSWriter const * 0 0 852 0 0 0 0 0 0 0 0 0 0

852 14 SSWriter const 0 8832 14 SSWriter const 14 SSWriter const 0 0 793 0 0 0 0 0 0 0 0 0 0

853 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

854 15 ISocketStream * 0 8576 15 ISocketStream * 15 ISocketStream * 0 0 794 0 0 0 0 0 0 0 0 0 0

855 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 795 0 0 0 0 0 0 0 0 0 0

856 15 OSocketStream * 0 8576 15 OSocketStream * 15 OSocketStream * 0 0 797 0 0 0 0 0 0 0 0 0 0

857 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 798 0 0 0 0 0 0 0 0 0 0

858 14 SocketStream * 0 8576 14 SocketStream * 14 SocketStream * 0 0 799 0 0 0 0 0 0 0 0 0 0

859 20 SocketStream const * 0 8576 20 SocketStream const * 20 SocketStream const * 0 0 860 0 0 0 0 0 0 0 0 0 0

860 18 SocketStream const 0 8832 18 SocketStream const 18 SocketStream const 0 0 799 0 0 0 0 0 0 0 0 0 0

861 10 iostream * 0 8576 15 std::iostream * 15 std::iostream * 0 0 800 0 0 0 0 0 0 0 0 0 0

862 9 URLSpec * 0 8576 9 URLSpec * 9 URLSpec * 0 0 801 0 0 0 0 0 0 0 0 0 0

863 15 URLSpec const * 0 8576 15 URLSpec const * 15 URLSpec const * 0 0 819 0 0 0 0 0 0 0 0 0 0

864 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 865 0 0 0 0 0 0 0 0 0 0

865 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 866 0 0 0 0 0 0 0 0 0 0

866 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

867 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

868 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 869 0 0 0 0 0 0 0 0 0 0

869 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

870 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

871 10 HTTPEnum * 0 8576 10 HTTPEnum * 10 HTTPEnum * 0 0 807 0 0 0 0 0 0 0 0 0 0

872 16 HTTPEnum const * 0 8576 16 HTTPEnum const * 16 HTTPEnum const * 0 0 873 0 0 0 0 0 0 0 0 0 0

873 14 HTTPEnum const 0 8832 14 HTTPEnum const 14 HTTPEnum const 0 0 807 0 0 0 0 0 0 0 0 0 0

874 10 HTTPDate * 0 8576 10 HTTPDate * 10 HTTPDate * 0 0 810 0 0 0 0 0 0 0 0 0 0

875 16 HTTPDate const * 0 8576 16 HTTPDate const * 16 HTTPDate const * 0 0 821 0 0 0 0 0 0 0 0 0 0

876 6 time_t 0 2105344 6 time_t 6 time_t 0 0 877 0 0 0 0 0 0 0 0 0 0

877 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

878 12 HTTPCookie * 0 8576 12 HTTPCookie * 12 HTTPCookie * 0 0 811 0 0 0 0 0 0 0 0 0 0

879 18 HTTPCookie const * 0 8576 18 HTTPCookie const * 18 HTTPCookie const * 0 0 880 0 0 0 0 0 0 0 0 0 0

880 16 HTTPCookie const 0 8832 16 HTTPCookie const 16 HTTPCookie const 0 0 811 0 0 0 0 0 0 0 0 0 0

881 12 HTTPClient * 0 8576 12 HTTPClient * 12 HTTPClient * 0 0 812 0 0 0 0 0 0 0 0 0 0

882 18 HTTPClient const * 0 8576 18 HTTPClient const * 18 HTTPClient const * 0 0 883 0 0 0 0 0 0 0 0 0 0

883 16 HTTPClient const 0 8832 16 HTTPClient const 16 HTTPClient const 0 0 812 0 0 0 0 0 0 0 0 0 0

884 13 HTTPChannel * 0 8576 13 HTTPChannel * 13 HTTPChannel * 0 0 822 0 0 0 0 0 0 0 0 0 0

885 15 HTTPEntityTag * 0 8576 15 HTTPEntityTag * 15 HTTPEntityTag * 0 0 815 0 0 0 0 0 0 0 0 0 0

886 21 HTTPEntityTag const * 0 8576 21 HTTPEntityTag const * 21 HTTPEntityTag const * 0 0 820 0 0 0 0 0 0 0 0 0 0

887 14 DocumentSpec * 0 8576 14 DocumentSpec * 14 DocumentSpec * 0 0 816 0 0 0 0 0 0 0 0 0 0

888 20 DocumentSpec const * 0 8576 20 DocumentSpec const * 20 DocumentSpec const * 0 0 889 0 0 0 0 0 0 0 0 0 0

889 18 DocumentSpec const 0 8832 18 DocumentSpec const 18 DocumentSpec const 0 0 816 0 0 0 0 0 0 0 0 0 0

890 19 HTTPChannel const * 0 8576 19 HTTPChannel const * 19 HTTPChannel const * 0 0 891 0 0 0 0 0 0 0 0 0 0

891 17 HTTPChannel const 0 8832 17 HTTPChannel const 17 HTTPChannel const 0 0 822 0 0 0 0 0 0 0 0 0 0

892 10 streamsize 0 2105344 15 std::streamsize 15 std::streamsize 0 0 893 0 0 0 0 0 0 0 0 0 0

893 13 long long int 0 8226 13 long long int 13 long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

894 9 Ramfile * 0 8576 9 Ramfile * 9 Ramfile * 0 0 895 0 0 0 0 0 0 0 0 0 0

895 7 Ramfile 0 2048 7 Ramfile 7 Ramfile 0 0 0 0 0 0 0 0 0 0 0 0 85
/**
 * An in-memory buffer specifically designed for downloading files to memory.
 */

896 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

897 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 896 0 0 0 0 0 0 0 0 0 0

898 14 Decompressor * 0 8576 14 Decompressor * 14 Decompressor * 0 0 825 0 0 0 0 0 0 0 0 0 0

899 20 Decompressor const * 0 8576 20 Decompressor const * 20 Decompressor const * 0 0 900 0 0 0 0 0 0 0 0 0 0

900 18 Decompressor const 0 8832 18 Decompressor const 18 Decompressor const 0 0 825 0 0 0 0 0 0 0 0 0 0

901 12 DownloadDb * 0 8576 12 DownloadDb * 12 DownloadDb * 0 0 828 0 0 0 0 0 0 0 0 0 0

902 18 DownloadDb const * 0 8576 18 DownloadDb const * 18 DownloadDb const * 0 0 903 0 0 0 0 0 0 0 0 0 0

903 16 DownloadDb const 0 8832 16 DownloadDb const 16 DownloadDb const 0 0 828 0 0 0 0 0 0 0 0 0 0

904 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 866 0 0 0 0 0 0 0 0 0 0

905 5 Phase 0 2105344 5 Phase 5 Phase 0 0 826 0 0 0 0 0 0 0 0 0 0

906 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 109
/**
 * Stores a 128-bit value that represents the hashed contents (typically MD5)
 * of a file or buffer.
 */

907 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 906 0 0 0 0 0 0 0 0 0 0

908 2 Db 0 1312768 14 DownloadDb::Db 14 DownloadDb::Db 828 0 0 0 0 0 0 0 0 0 0 0 0

909 4 Db * 0 8576 16 DownloadDb::Db * 16 DownloadDb::Db * 0 0 908 0 0 0 0 0 0 0 0 0 0

910 15 HashVal const * 0 8576 15 HashVal const * 15 HashVal const * 0 0 911 0 0 0 0 0 0 0 0 0 0

911 13 HashVal const 0 8832 13 HashVal const 13 HashVal const 0 0 906 0 0 0 0 0 0 0 0 0 0

912 11 Extractor * 0 8576 11 Extractor * 11 Extractor * 0 0 830 0 0 0 0 0 0 0 0 0 0

913 17 Extractor const * 0 8576 17 Extractor const * 17 Extractor const * 0 0 914 0 0 0 0 0 0 0 0 0 0

914 15 Extractor const 0 8832 15 Extractor const 15 Extractor const 0 0 830 0 0 0 0 0 0 0 0 0 0

915 17 MultiplexStream * 0 8576 17 MultiplexStream * 17 MultiplexStream * 0 0 831 0 0 0 0 0 0 0 0 0 0

916 6 FILE * 0 8576 6 FILE * 6 FILE * 0 0 917 0 0 0 0 0 0 0 0 0 0

917 4 FILE 0 1024 4 FILE 4 FILE 0 0 0 0 0 0 0 0 0 0 0 0 0

918 22 VirtualFileMountHTTP * 0 8576 22 VirtualFileMountHTTP * 22 VirtualFileMountHTTP * 0 0 834 0 0 0 0 0 0 0 0 0 0

919 28 VirtualFileMountHTTP const * 0 8576 28 VirtualFileMountHTTP const * 28 VirtualFileMountHTTP const * 0 0 920 0 0 0 0 0 0 0 0 0 0

920 26 VirtualFileMountHTTP const 0 8832 26 VirtualFileMountHTTP const 26 VirtualFileMountHTTP const 0 0 834 0 0 0 0 0 0 0 0 0 0

921 9 Patcher * 0 8576 9 Patcher * 9 Patcher * 0 0 836 0 0 0 0 0 0 0 0 0 0

922 15 Patcher const * 0 8576 15 Patcher const * 15 Patcher const * 0 0 923 0 0 0 0 0 0 0 0 0 0

923 13 Patcher const 0 8832 13 Patcher const 13 Patcher const 0 0 836 0 0 0 0 0 0 0 0 0 0

924 8 Buffer * 0 8576 8 Buffer * 8 Buffer * 0 0 925 0 0 0 0 0 0 0 0 0 0

925 6 Buffer 0 2048 6 Buffer 6 Buffer 0 0 0 0 0 0 0 0 0 0 0 0 10
/**
 *
 */

926 14 StringStream * 0 8576 14 StringStream * 14 StringStream * 0 0 837 0 0 0 0 0 0 0 0 0 0

927 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

928 19 PointerTo< Buffer > 0 2048 19 PointerTo< Buffer > 19 PointerTo< Buffer > 0 0 0 0 0 0 0 0 0 0 0 0 0

0
17
929 6 scheme 0 6 802 459 473 0 0 0 0 0 0 15 URLSpec::scheme 0

930 9 authority 0 6 802 460 474 0 0 0 0 0 0 18 URLSpec::authority 0

931 8 username 0 6 802 461 475 0 0 0 0 0 0 17 URLSpec::username 0

932 6 server 0 6 802 462 476 0 0 0 0 0 0 15 URLSpec::server 0

933 4 port 0 6 804 464 477 0 0 0 0 0 0 13 URLSpec::port 0

934 15 server_and_port 0 6 802 465 478 0 0 0 0 0 0 24 URLSpec::server_and_port 0

935 4 path 0 6 802 468 479 0 0 0 0 0 0 13 URLSpec::path 0

936 5 query 0 6 802 469 480 0 0 0 0 0 0 14 URLSpec::query 0

937 3 ssl 0 2 806 471 0 0 0 0 0 0 0 12 URLSpec::ssl 0

938 3 url 0 6 819 607 606 0 0 0 0 0 0 17 DocumentSpec::url 0

939 3 tag 0 30 820 610 608 609 611 0 0 0 0 17 DocumentSpec::tag 0

940 4 date 0 30 821 614 612 613 615 0 0 0 0 18 DocumentSpec::date 0

941 12 request_mode 0 6 817 617 616 0 0 0 0 0 0 26 DocumentSpec::request_mode 0

942 13 cache_control 0 6 818 619 618 0 0 0 0 0 0 27 DocumentSpec::cache_control 0

943 8 progress 0 2 826 707 0 0 0 0 0 0 0 22 Decompressor::progress 0

944 8 progress 0 2 826 765 0 0 0 0 0 0 0 19 Extractor::progress 0

945 4 data 0 6 838 789 790 0 0 0 0 0 0 18 StringStream::data 0

1
946 18 get_redirect_steps 0 637 638 31 HTTPChannel::get_redirect_steps 0

